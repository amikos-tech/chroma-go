name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  pull-requests: read

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version-file: 'go.mod'

      - name: Run tests
        run: |
          make build
          make lint

      - name: Extract version from tag
        id: version
        run: |
          echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          echo "VERSION_NUMBER=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: release_notes
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.generateReleaseNotes({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ steps.version.outputs.VERSION }}'
            });

            // Parse and reorganize the release notes
            let body = data.body;

            // Add version and release date header
            const header = `## Release ${{ steps.version.outputs.VERSION }}\n\n**Released**: ${new Date().toISOString().split('T')[0]}\n\n`;

            // Categorize changes based on conventional commit prefixes
            const categories = {
              'ðŸš€ Features': /\* .*feat[(\[]|^feat:/gm,
              'ðŸ› Bug Fixes': /\* .*fix[(\[]|^fix:/gm,
              'ðŸ“š Documentation': /\* .*docs[(\[]|^docs:/gm,
              'ðŸ”§ Maintenance': /\* .*chore[(\[]|^chore:/gm,
              'â™»ï¸ Refactoring': /\* .*refactor[(\[]|^refactor:/gm,
              'âš¡ Performance': /\* .*perf[(\[]|^perf:/gm,
              'âœ… Tests': /\* .*test[(\[]|^test:/gm,
            };

            let categorized = header;
            const lines = body.split('\n');
            const processedLines = new Set();

            // Add breaking changes section at top if any
            const breakingChanges = lines.filter(line =>
              line.includes('BREAKING CHANGE') || line.includes('!')
            );
            if (breakingChanges.length > 0) {
              categorized += '## âš ï¸ Breaking Changes\n\n';
              breakingChanges.forEach(line => {
                categorized += line + '\n';
                processedLines.add(line);
              });
              categorized += '\n';
            }

            // Add categorized changes
            for (const [category, pattern] of Object.entries(categories)) {
              const matches = lines.filter(line =>
                pattern.test(line) && !processedLines.has(line)
              );
              if (matches.length > 0) {
                categorized += `### ${category}\n\n`;
                matches.forEach(line => {
                  categorized += line + '\n';
                  processedLines.add(line);
                });
                categorized += '\n';
              }
            }

            // Add other changes
            const uncategorized = lines.filter(line =>
              (line.startsWith('* ') || line.startsWith('- ')) &&
              !processedLines.has(line) &&
              !line.includes('## What\'s Changed') &&
              !line.includes('**Full Changelog**')
            );
            if (uncategorized.length > 0) {
              categorized += '### ðŸ“¦ Other Changes\n\n';
              uncategorized.forEach(line => categorized += line + '\n');
              categorized += '\n';
            }

            // Add contributors section
            const contributorsSection = body.split('## New Contributors')[1];
            if (contributorsSection) {
              categorized += '## New Contributors\n' + contributorsSection;
            }

            // Add full changelog link
            const fullChangelogMatch = body.match(/\*\*Full Changelog\*\*: (.*)/);
            if (fullChangelogMatch) {
              categorized += `\n**Full Changelog**: ${fullChangelogMatch[1]}`;
            }

            return categorized;
          result-encoding: string

      - name: Create Release
        uses: actions/github-script@v7
        with:
          script: |
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ steps.version.outputs.VERSION }}',
              name: 'Release ${{ steps.version.outputs.VERSION }}',
              body: `${{ steps.release_notes.outputs.result }}`,
              draft: false,
              prerelease: ${{ contains(steps.version.outputs.VERSION, '-') }},
              generate_release_notes: false
            });

            core.info(`Release created: ${release.data.html_url}`);

      - name: Trigger pkg.go.dev update
        run: |
          # Request pkg.go.dev to fetch the new version
          curl -X POST "https://proxy.golang.org/github.com/amikos-tech/chroma-go/@v/${{ steps.version.outputs.VERSION }}.info" || true

          # Also request the latest version
          curl "https://proxy.golang.org/github.com/amikos-tech/chroma-go/@latest" || true

          echo "âœ… Requested pkg.go.dev to update. It may take a few minutes to appear."
          echo "Check: https://pkg.go.dev/github.com/amikos-tech/chroma-go@${{ steps.version.outputs.VERSION }}"
