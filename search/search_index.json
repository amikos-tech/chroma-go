{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chroma Go Client","text":"<p>An experimental Go client for ChromaDB.</p>"},{"location":"#installation","title":"Installation","text":"<p>Add the library to your project:</p> <pre><code>go get github.com/amikos-tech/chroma-go\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Concepts:</p> <ul> <li>Client Options - How to configure chroma go client</li> <li>Embeddings - List of available embedding functions and how to use them</li> <li>Records - How to work with records</li> <li>Filtering - How to filter results</li> </ul> <p>Import the library:</p> <pre><code>package main\n\nimport (\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/collection\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n</code></pre> <p>New client:</p> <p>Note</p> <p>Check Client Options for more details.</p> <pre><code>package main\n\nimport (\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"fmt\"\n)\n\nfunc main() {\n    client,err := chroma.NewClient(chroma.WithBasePath(\"http://localhost:8000\"))\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n    // do something with client\n}\n</code></pre>"},{"location":"#embedding-functions","title":"Embedding Functions","text":"<p>The client supports a number of embedding wrapper functions. See Embeddings for more details.</p>"},{"location":"#crud-operations","title":"CRUD Operations","text":"<p>Ensure you have a running instance of Chroma running. See this doc for more info how to run local Chroma instance.</p> <p>Here's a simple example of creating a new collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    openai \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client,err := chroma.NewClient() //connects to localhost:8000\\\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n\n    // Create a new collection with OpenAI embedding function, L2 distance function and metadata\n    _, err = client.CreateCollection(ctx, \"my-collection\", map[string]interface{}{\"key1\": \"value1\"}, true, openaiEf, types.L2)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n    }\n\n    // Get collection\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to get collection: %v\", err)\n    }\n\n    // Modify collection\n    _, err = collection.Update(ctx, \"new-collection\",nil)\n    if err != nil {\n        log.Fatalf(\"Failed to update collection: %v\", err)\n    }\n\n    // Delete collection\n    _, err = client.DeleteCollection(ctx, \"new-collection\")\n    if err != nil {\n        log.Fatalf(\"Failed to delete collection: %v\", err)\n    }\n}\n</code></pre>"},{"location":"#add-documents","title":"Add documents","text":"<p>Here's a simple example of adding documents to a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client, err := chroma.NewClient() //connects to localhost:8000\n    if err !=nil{\n        log.Fatalf(\"Failed to create client: %v\", err)\n    }\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    _, err = collection.Add(context.TODO(), nil, []map[string]interface{}{{\"key1\": \"value1\"}}, []string{\"My name is John and I have three dogs.\"}, []string{\"ID1\"})\n    if err != nil {\n        log.Fatalf(\"Error adding documents: %v\\n\", err)\n        return\n    }\n    data, err := collection.Get(context.TODO(), nil, nil, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error getting documents: %v\\n\", err)\n        return\n    }\n    // see GetResults struct for more details\n    fmt.Printf(\"Collection data: %v\\n\", data)\n}\n</code></pre>"},{"location":"#query-collection","title":"Query Collection","text":"<p>Here's a simple example of querying documents in a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client,err := chroma.NewClient() //connects to localhost:8000\n\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    data, err := collection.Query(context.TODO(), []string{\"I love dogs\"}, 5, nil, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error querying documents: %v\\n\", err)\n        return\n    }\n    // see QueryResults struct for more details\n    fmt.Printf(\"Collection data: %v\\n\", data)\n}\n</code></pre>"},{"location":"#delete-documents","title":"Delete Documents","text":"<p>Here's a simple example of deleting documents from a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client,err := chroma.NewClient() //connects to localhost:8000\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    _, err = collection.Delete(context.TODO(), []string{\"ID1\"}, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error deleting documents: %v\\n\", err)\n        return\n    }\n    fmt.Printf(\"Documents deleted\\n\")\n}\n</code></pre>"},{"location":"auth/","title":"Authentication","text":"<p>There are four ways to authenticate with Chroma:</p> <ul> <li>Manual Header authentication - this approach requires you to be familiar with the server-side auth and generate and insert the necessary headers manually.</li> <li>Chroma Basic Auth mechanism</li> <li>Chroma Token Auth mechanism with Bearer Authorization header</li> <li>Chroma Token Auth mechanism with X-Chroma-Token header</li> </ul>"},{"location":"auth/#manual-header-authentication","title":"Manual Header Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    var defaultHeaders = map[string]string{\"Authorization\": \"Bearer my-custom-token\"}\n    clientWithTenant, err := chroma.NewClient(chroma.WithBasePath(\"http://api.trychroma.com/v1/\"), chroma.WithDefaultHeaders(defaultHeaders))\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = clientWithTenant.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-basic-auth-mechanism","title":"Chroma Basic Auth mechanism","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://api.trychroma.com/v1/\"),\n        chroma.WithAuth(types.NewBasicAuthCredentialsProvider(\"myUser\", \"myPassword\")),\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = client.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-token-auth-mechanism-with-bearer-authorization-header","title":"Chroma Token Auth mechanism with Bearer Authorization header","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://api.trychroma.com/v1/\"), \n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-auth-token\", types.AuthorizationTokenHeader)),\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = client.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-token-auth-mechanism-with-x-chroma-token-header","title":"Chroma Token Auth mechanism with X-Chroma-Token header","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://api.trychroma.com/v1/\"), \n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-auth-token\", types.XChromaTokenHeader)),\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = client.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"client/","title":"Chroma Client","text":""},{"location":"client/#chroma-cloud-client-v020","title":"Chroma Cloud Client (v0.2.0+)","text":"<p>Options:</p> Options Usage Description Value Required CloudAPIKey <code>WithCloudAPIKey(\"api_key\")</code> Set Chroma Cloud API Key <code>string</code> Yes (default: uses <code>CHROMA_API_KEY</code> env var if available) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> Yes (default: uses <code>CHROMA_TENANT</code> env var if available) Database <code>WithDatabaseAndTenant(\"database\",\"tenant\")</code> The default database and tenant (overrides any tenant set with Tenant). Option precedence is observed! <code>string</code> Yes (default: uses <code>CHROMA_DATABASE</code> env var if available) Debug <code>WithDebug(true/false)</code> Enable debug mode, printing http requests to stdout (sensitive information is sanitized) <code>bool</code> No (default: <code>false</code>) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default HTTP headers for the client. These headers are sent with every request. <code>map[string]string</code> No (default: <code>nil</code>) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) Timeout <code>WithTimeout(time.Duration)</code> Set the timeout for the client. <code>time.Duration</code> No (default is the default HTTP client timeout duration) <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n    \"log\"\n)\n\nfunc main() {\n    c, err := chroma.NewHTTPClient(\n        chroma.WithCloudAPIKey(\"my-api-key\"),\n        chroma.WithDatabaseAndTenant(\"team-uuid\", \"my-database\"),\n        chroma.WithDebug(), // enable debug output (sensitive token information is sanitized)\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    v, err := c.GetVersion(context.Background())\n    if err != nil {\n        log.Fatalf(\"Error getting version: %s \\n\", err)\n    }\n    fmt.Printf(\"Chroma API Version: %s \\n\", v)\n}\n</code></pre>"},{"location":"client/#chroma-client-v020","title":"Chroma Client (v0.2.0+)","text":"<p>Options:</p> Options Usage Description Value Required API Endpoint <code>WithBasePath(\"http://localhost:8000\")</code> The Chroma server base API. Non-empty valid URL string No (default: <code>http://localhost:8000</code>) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> No (default: <code>default_tenant</code>) Database <code>WithDatabaseAndTenant(\"database\",\"tenant\")</code> The default database to use. <code>string</code> No (default: <code>default_database</code>) Debug <code>WithDebug(true/false)</code> Enable debug mode. <code>bool</code> No (default: <code>false</code>) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default HTTP headers for the client. These headers are sent with every request. <code>map[string]string</code> No (default: <code>nil</code>) SSL Cert <code>WithSSLCert(\"path/to/cert.pem\")</code> Set the path to the SSL certificate. valid path to SSL cert. No (default: Not Set) Insecure <code>WithInsecure()</code> Disable SSL certificate verification No (default: Not Set) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) Auth <code>WithAuth(v2.CredentialsProvider)</code> Set the authentication method. The default is <code>WithAuth(types.NewNoAuthCredentialsProvider())</code> <code>CredentialsProvider</code> No (default: <code>NoAuth</code>) Timeout <code>WithTimeout(time.Duration)</code> Set the timeout for the client. <code>time.Duration</code> No (default is the default HTTP client timeout duration) Transport <code>WithTransport(*http.Transport)</code> Set the transport for the client. <code>http.RoundTripper</code> No (default: Default HTTPClient) <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n    \"log\"\n)\n\nfunc main() {\n    c, err := chroma.NewHTTPClient(\n        chroma.WithBaseURL(\"http://localhost:8000\"),\n        chroma.WithDatabaseAndTenant(\"default_database\", \"default_tenant\"),\n        chroma.WithDefaultHeaders(map[string]string{\"X-Custom-Header\": \"header-value\"}),\n        chroma.WithDebug(), // enable debug output (sensitive token information is sanitized)\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    v, err := c.GetVersion(context.Background())\n    if err != nil {\n        log.Fatalf(\"Error getting version: %s \\n\", err)\n    }\n    fmt.Printf(\"Chroma API Version: %s \\n\", v)\n}\n</code></pre>"},{"location":"client/#client-version-v014-or-lower","title":"Client version v0.1.4 or lower","text":"<p>Options:</p> Options Usage Description Value Required basePath <code>WithBasePath(\"http://localhost:8000\")</code> The Chroma server base API. Non-empty valid URL string No (default: <code>http://localhost:8000</code>) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> No (default: <code>default_tenant</code>) Database <code>WithDatabase(\"database\")</code> The default database to use. <code>string</code> No (default: <code>default_database</code>) Debug <code>WithDebug(true/false)</code> Enable debug mode. <code>bool</code> No (default: <code>false</code>) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default headers for the client. <code>map[string]string</code> No (default: <code>nil</code>) SSL Cert <code>WithSSLCert(\"path/to/cert.pem\")</code> Set the path to the SSL certificate. valid path to SSL cert. No (default: Not Set) Insecure <code>WithInsecure()</code> Disable SSL certificate verification No (default: Not Set) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) <p>Tenant and Database</p> <p>The tenant and database are only supported for Chroma API version <code>0.4.15+</code>.</p> <p>Creating a new client:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithTenant(\"my_tenant\"),\n        chroma.WithDatabase(\"my_db\"),\n        chroma.WithDebug(true),\n        chroma.WithDefaultHeaders(map[string]string{\"Authorization\": \"Bearer my token\"}),\n        chroma.WithSSLCert(\"path/to/cert.pem\"),\n    )\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n    // do something with client\n\n    // Close the client to release any resources such as local embedding functions\n    err = client.Close()\n    if err != nil {\n        fmt.Printf(\"Failed to close client: %v\", err)\n    }\n}\n</code></pre>"},{"location":"embeddings/","title":"Embedding Models","text":"<p>The following embedding wrappers are available:</p> Embedding Model Description Default Embeddings The default Chroma embedding function running <code>all-MiniLM-L6-v2</code> on Onnx Runtime OpenAI OpenAI embeddings API.All models are supported - see OpenAI docs for more info. Cohere Cohere embeddings API.All models are supported - see Cohere API docs for more info. HuggingFace Inference API HuggingFace Inference API.All models supported by the API. HuggingFace Embedding Inference Server HuggingFace Embedding Inference Server.Models supported by the inference server. Ollama Ollama embeddings API.All models are supported - see Ollama models lib for more info. Cloudflare Workers AI Cloudflare Workers AI Embedding. For more info see CF API Docs. Together AI Together AI Embedding. For more info see Together API Docs. Voyage AI Voyage AI Embedding. For more info see Together API Docs. Google Gemini Google Gemini Embedding. For more info see Gemini Docs. Mistral AI Mistral AI Embedding. For more info see Mistral AI API Docs. Nomic AI Nomic AI Embedding. For more info see Nomic AI API Docs. Jina AI Jina AI Embedding. For more info see Nomic AI API Docs."},{"location":"embeddings/#default-embeddings","title":"Default Embeddings","text":"<p>Note: Supported from 0.2.0+</p> <p>The default embedding function uses the <code>all-MiniLM-L6-v2</code> model running on Onnx Runtime. The default EF is configured by default if no EF is provided when creating or getting a collection.</p> <p>Note: As the EF relies on C bindings to avoid memory leaks make sure to call the close callback, alternatively if you are passing the EF to a client e.g. when getting or creating a collection you can use the client's close method to ensure proper resource release.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    defaultef \"github.com/amikos-tech/chroma-go/pkg/embeddings/default_ef\"\n)\n\nfunc main() {\n    ef, closeef, efErr := defaultef.NewDefaultEmbeddingFunction()\n\n    // make sure to call this to ensure proper resource release\n    defer func() {\n        err := closeef()\n        if err != nil {\n            fmt.Printf(\"Error closing default embedding function: %s \\n\", err)\n        }\n    }()\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#openai","title":"OpenAI","text":"<p>Supported Embedding Function Options:</p> <ul> <li><code>WithModel</code> - Set the OpenAI model to use. Default is <code>TextEmbeddingAda002</code> (<code>text-embedding-ada-002</code>).</li> <li><code>WithBaseURL</code> - Set the OpenAI base URL. Default is <code>https://api.openai.com/v1</code>. This allows you to point the EF to a   compatible OpenAI API endpoint.</li> <li><code>WithDimensions</code> - Set the number of dimensions for the embeddings. Default is <code>None</code> which returns the full   embeddings.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    openai \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ef, efErr := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"), openai.WithModel(openai.TextEmbedding3Large))\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cohere","title":"Cohere","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    cohere \"github.com/amikos-tech/chroma-go/pkg/embeddings/cohere\"\n)\n\nfunc main() {\n    ef := cohere.NewCohereEmbeddingFunction(os.Getenv(\"COHERE_API_KEY\"))\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-inference-api","title":"HuggingFace Inference API","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/pkg/embeddings/hf\"\n)\n\nfunc main() {\n    ef := huggingface.NewHuggingFaceEmbeddingFunction(os.Getenv(\"HUGGINGFACE_API_KEY\"), \"sentence-transformers/all-MiniLM-L6-v2\")\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-embedding-inference-server","title":"HuggingFace Embedding Inference Server","text":"<p>The embedding server allows you to run supported model locally on your machine with CPU and GPU inference. For more information check the HuggingFace Embedding Inference Server repository.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/hf\"\n)\n\nfunc main() {\n    ef, err := huggingface.NewHuggingFaceEmbeddingInferenceFunction(\"http://localhost:8001/embed\") //set this to the URL of the HuggingFace Embedding Inference Server\n    if err != nil {\n        fmt.Printf(\"Error creating HuggingFace embedding function: %s \\n\", err)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#ollama","title":"Ollama","text":"<p>Assumptions</p> <p>The below example assumes that you have an Ollama server running locally on <code>http://127.0.0.1:11434</code>.</p> <p>Use the following command to start the Ollama server:</p> <pre><code>    docker run -d -v ./ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama\n    docker exec -it ollama ollama run nomic-embed-text # press Ctrl+D to exit after model downloads successfully\n    # test it\n    curl http://localhost:11434/api/embed -d '{\"model\": \"nomic-embed-text\",\"input\": [\"Here is an article about llamas...\"]}'\n ```\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    ollama \"github.com/amikos-tech/chroma-go/pkg/embeddings/ollama\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // the `/api/embeddings` endpoint is automatically appended to the base URL\n    ef, err := ollama.NewOllamaEmbeddingFunction(ollama.WithBaseURL(\"http://127.0.0.1:11434\"), ollama.WithModel(\"nomic-embed-text\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Ollama embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cloudflare-workers-ai","title":"Cloudflare Workers AI","text":"<p>You will need to register for a Cloudflare account and create a API Token for Workers AI - see docs for more info.</p> <p>Models can be found in the Cloudflare Workers AI docs. <code>@cf/baai/bge-base-en-v1.5</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    cf \"github.com/amikos-tech/chroma-go/pkg/embeddings/cloudflare\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `CF_API_TOKEN` and `CF_ACCOUNT_ID` set in your environment\n    ef, err := cf.NewCloudflareEmbeddingFunction(cf.WithEnvAPIToken(), cf.WithEnvAccountID(), cf.WithDefaultModel(\"@cf/baai/bge-small-en-v1.5\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Cloudflare embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#together-ai","title":"Together AI","text":"<p>To use Together AI embeddings, you will need to register for a Together AI account and create an API Key.</p> <p>Available models can be in Together AI docs. <code>togethercomputer/m2-bert-80M-8k-retrieval</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/together\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `TOGETHER_API_KEY` set in your environment\n    ef, err := t.NewTogetherEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"togethercomputer/m2-bert-80M-2k-retrieval\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#voyage-ai","title":"Voyage AI","text":"<p>To use Voyage AI embeddings, you will need to register for a Voyage AI account and create an API Key.</p> <p>Available models can be in Voyage AI docs. <code>voyage-2</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/voyage\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `VOYAGE_API_KEY` set in your environment\n    ef, err := t.NewVoyageAIEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"voyage-large-2\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#google-gemini","title":"Google Gemini","text":"<p>To use Google Gemini AI embeddings, you will need to create an API Key.</p> <p>Available models can be in Gemini Models. <code>text-embedding-004</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    g \"github.com/amikos-tech/chroma-go/pkg/embeddings/gemini\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `GEMINI_API_KEY` set in your environment\n    ef, err := g.NewGeminiEmbeddingFunction(g.WithEnvAPIKey(), g.WithDefaultModel(\"text-embedding-004\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Gemini embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#mistral-ai","title":"Mistral AI","text":"<p>To use Mistral AI embeddings, you will need to create an API Key.</p> <p>Currently, (as of July 2024) only <code>mistral-embed</code> model is available, which is the default model we use.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    mistral \"github.com/amikos-tech/chroma-go/pkg/embeddings/mistral\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `MISTRAL_API_KEY` set in your environment\n    ef, err := mistral.NewMistralEmbeddingFunction(mistral.WithEnvAPIKey(), mistral.WithDefaultModel(\"mistral-embed\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Mistral embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#nomic-ai","title":"Nomic AI","text":"<p>To use Nomic AI embeddings, you will need to create an API Key.</p> <p>Supported models - https://docs.nomic.ai/atlas/models/text-embedding</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    nomic \"github.com/amikos-tech/chroma-go/pkg/embeddings/nomic\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `NOMIC_API_KEY` set in your environment\n    ef, err := nomic.NewNomicEmbeddingFunction(nomic.WithEnvAPIKey(), nomic.WithDefaultModel(nomic.NomicEmbedTextV1))\n    if err != nil {\n        fmt.Printf(\"Error creating Nomic embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#jina-ai","title":"Jina AI","text":"<p>To use Jina AI embeddings, you will need to get an API Key (trial API keys are freely available without any registration, scroll down the page and find the automatically generated API key).</p> <p>Supported models - https://api.jina.ai/redoc#tag/embeddings/operation/create_embedding_v1_embeddings_post</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    jina \"github.com/amikos-tech/chroma-go/pkg/embeddings/jina\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `JINA_API_KEY` set in your environment\n    ef, err := jina.NewJinaEmbeddingFunction(jina.WithEnvAPIKey())\n    if err != nil {\n        fmt.Printf(\"Error creating Jina embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"filtering/","title":"Filtering","text":"<p>Chroma offers two types of filters:</p> <ul> <li>Metadata - filtering based on metadata attribute values</li> <li>Documents - filtering based on document content (contains or not contains)</li> </ul>"},{"location":"filtering/#metadata","title":"Metadata","text":"<ul> <li>TODO - Add builder example</li> <li>TODO - Describe all available operations</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    \"github.com/amikos-tech/chroma-go/where\"\n)\n\nfunc main() {\n    embeddingF, err := openai.NewOpenAIEmbeddingFunction(\"sk-xxxx\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    client, err := chroma.NewClient() // connects to localhost:8000\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    collection, err := client.GetCollection(context.TODO(), \"my-collection\", embeddingF)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // Filter by metadata\n\n    result, err := collection.GetWithOptions(\n        context.Background(),\n        types.WithWhere(\n            where.Or(\n                where.Eq(\"category\", \"Chroma\"),\n                where.Eq(\"type\", \"vector database\"),\n            ),\n        ),\n    )\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // do something with result\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"filtering/#document","title":"Document","text":"<ul> <li>TODO - Add builder example</li> <li>TODO - Describe all available operations</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    \"github.com/amikos-tech/chroma-go/where_document\"\n)\n\nfunc main() {\n    embeddingF, err := openai.NewOpenAIEmbeddingFunction(\"sk-xxxx\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    client, err := chroma.NewClient(chroma.WithBasePath(\"http://localhost:8000\"))\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    collection, err := client.GetCollection(context.TODO(), \"my-collection\", embeddingF)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // Filter by metadata\n\n    result, err := collection.GetWithOptions(\n        context.Background(),\n        types.WithWhereDocument(\n            wheredoc.Or(\n                wheredoc.Contains(\"Vector database\"),\n                wheredoc.Contains(\"Chroma\"),\n            ),\n        ),\n    )\n\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // do something with result\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"records/","title":"Records","text":"<p>Records are a mechanism that allows you to manage Chroma documents as a cohesive unit. This has several advantages over the traditional approach of managing documents, ids, embeddings, and metadata separately.</p> <p>Two concepts are important to keep in mind here:</p> <ul> <li>Record - corresponds to a single document in Chroma which includes id, embedding, metadata, the document or URI</li> <li>RecordSet - a single unit of work to insert, upsert, update or delete records.</li> </ul>"},{"location":"records/#record","title":"Record","text":"<p>A Record contains the following fields:</p> <ul> <li>ID (string)</li> <li>Document (string) - optional</li> <li>Metadata (map[string]interface{}) - optional</li> <li>Embedding ([]float32 or []int32, wrapped in Embedding struct)</li> <li>URI (string) - optional</li> </ul> <p>Here's the <code>Record</code> type:</p> <pre><code>package types\n\ntype Record struct {\n    ID        string\n    Embedding Embedding\n    Metadata  map[string]interface{}\n    Document  string\n    URI       string\n    err       error // indicating whether the record is valid\n}\n</code></pre>"},{"location":"records/#recordset","title":"RecordSet","text":"<p>A record set is a cohesive unit of work, allowing the user to add, upsert, update, or delete records.</p> <p>Operation support</p> <p>Currently the record set only supports add operation</p> <pre><code>rs, rerr := types.NewRecordSet(\n            types.WithEmbeddingFunction(types.NewConsistentHashEmbeddingFunction()),\n            types.WithIDGenerator(types.NewULIDGenerator()),\n        )\nif err != nil {\n    log.Fatalf(\"Error creating record set: %s\", err)\n}\n// you can loop here to add multiple records\nrs.WithRecord(types.WithDocument(\"Document 1 content\"), types.WithMetadata(\"key1\", \"value1\"))\nrs.WithRecord(types.WithDocument(\"Document 2 content\"), types.WithMetadata(\"key2\", \"value2\"))\nrecords, err = rs.BuildAndValidate(context.Background())\n</code></pre>"},{"location":"rerankers/","title":"Reranking Functions","text":"<p>Reranking functions allow users to feed Chroma results into a reranking model such as <code>cross-encoder/ms-marco-MiniLM-L-6-v2</code> to improve the quality of the search results.</p> <p>Rerankers take the returned documents from Chroma and the original query and rank each result's relevance to the query.</p>"},{"location":"rerankers/#how-to-use-rerankers","title":"How To Use Rerankers","text":"<p>Each reranker exposes the following methods:</p> <ul> <li><code>Rerank</code> which takes plain text query and results and returns a list of ranked results.</li> <li><code>RerankResults</code> which takes a <code>QueryResults</code> object and returns a list of <code>RerankedChromaResults</code> objects. RerankedChromaResults inherits from <code>QueryResults</code> and adds a <code>Ranks</code> field which contains the ranks of each result.</li> </ul> <pre><code>package rerankings\n\nimport (\n    \"context\"\n\n    chromago \"github.com/amikos-tech/chroma-go\"\n)\n\ntype RankedResult struct {\n    ID     int // Index in the original input []string\n    String string\n    Rank   float32\n}\n\ntype RerankedChromaResults struct {\n    chromago.QueryResults\n    Ranks [][]float32\n}\n\ntype RerankingFunction interface {\n    Rerank(ctx context.Context, query string, results []string) ([]*RankedResult, error)\n    RerankResults(ctx context.Context, queryResults *chromago.QueryResults) (RerankedChromaResults, error)\n}\n</code></pre>"},{"location":"rerankers/#supported-rerankers","title":"Supported Rerankers","text":"<ul> <li>Cohere - \u2705</li> <li>Jina AI - \u2705 </li> <li>HuggingFace Text Embedding Inference - \u2705</li> <li>HuggingFace Inference API - coming soon</li> </ul>"},{"location":"rerankers/#cohere-reranker","title":"Cohere Reranker","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    cohere \"github.com/amikos-tech/chroma-go/pkg/rerankings/cohere\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := cohere.NewCohereRerankingFunction(cohere.WithAPIKey(os.Getenv(\"COHERE_API_KEY\")))\n    if err != nil {\n        fmt.Printf(\"Error creating Cohere reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"rerankers/#jina-ai-reranker","title":"Jina AI Reranker","text":"<p>To use Jina AI reranking, you will need to get an API Key (trial API keys are freely available without any registration, scroll down the page and find the automatically generated API key).</p> <p>Supported models - https://api.jina.ai/redoc#tag/rerank/operation/rank_v1_rerank_post</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    jina \"github.com/amikos-tech/chroma-go/pkg/rerankings/jina\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := jina.NewJinaRerankingFunction(jina.WithAPIKey(os.Getenv(\"JINA_API_KEY\")))\n    if err != nil {\n        fmt.Printf(\"Error creating Jina reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"rerankers/#hfei-reranker","title":"HFEI Reranker","text":"<p>You need to run a local HFEI server. You can do that by running the following command:</p> <pre><code>docker run --rm -p 8080:80 -v $PWD/data:/data --platform linux/amd64 ghcr.io/huggingface/text-embeddings-inference:cpu-latest --model-id BAAI/bge-reranker-base\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    hf \"github.com/amikos-tech/chroma-go/pkg/rerankings/hf\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := hf.NewHFRerankingFunction(hf.WithRerankingEndpoint(\"http://127.0.0.1:8080/rerank\"))\n    if err != nil {\n        fmt.Printf(\"Error creating HFEI reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"}]}