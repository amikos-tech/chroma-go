{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Chroma Go Client","text":"<p>A Go client library for ChromaDB vector database.</p>"},{"location":"#installation","title":"Installation","text":"<p>Add the library to your project:</p> <pre><code>go get github.com/amikos-tech/chroma-go\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Import the V2 API:</p> <pre><code>package main\n\nimport (\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n</code></pre> <p>Concepts:</p> <ul> <li>Client Options - How to configure the Chroma Go client</li> <li>Embeddings - Available embedding functions</li> <li>Filtering - How to filter results</li> <li>Search API - Advanced search with ranking and pagination</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    ctx := context.Background()\n\n    // Create client (connects to localhost:8000 by default)\n    client, err := chroma.NewHTTPClient()\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s\", err)\n    }\n    defer client.Close()\n\n    // Create or get a collection\n    col, err := client.GetOrCreateCollection(ctx, \"my-collection\")\n    if err != nil {\n        log.Fatalf(\"Error creating collection: %s\", err)\n    }\n\n    // Add documents\n    err = col.Add(ctx,\n        chroma.WithIDs(\"doc1\", \"doc2\", \"doc3\"),\n        chroma.WithTexts(\n            \"Machine learning is a subset of AI\",\n            \"Natural language processing enables computers to understand text\",\n            \"Deep learning uses neural networks with many layers\",\n        ),\n        chroma.WithMetadatas(\n            map[string]any{\"category\": \"ml\", \"year\": 2024},\n            map[string]any{\"category\": \"nlp\", \"year\": 2024},\n            map[string]any{\"category\": \"dl\", \"year\": 2023},\n        ),\n    )\n    if err != nil {\n        log.Fatalf(\"Error adding documents: %s\", err)\n    }\n\n    // Query for similar documents\n    results, err := col.Query(ctx,\n        chroma.WithQueryTexts(\"What is artificial intelligence?\"),\n        chroma.WithNResults(2),\n    )\n    if err != nil {\n        log.Fatalf(\"Error querying: %s\", err)\n    }\n\n    fmt.Printf(\"Found %d results\\n\", len(results.GetIDsGroups()[0]))\n    for i, doc := range results.GetDocumentsGroups()[0] {\n        fmt.Printf(\"  %d: %s\\n\", i+1, doc)\n    }\n}\n</code></pre>"},{"location":"#unified-options-api","title":"Unified Options API","text":"<p>The V2 API uses a unified options pattern where common options work across multiple operations:</p> Option Get Query Delete Add Update Search <code>WithIDs</code> \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 <code>WithWhere</code> \u2713 \u2713 \u2713 <code>WithWhereDocument</code> \u2713 \u2713 \u2713 <code>WithInclude</code> \u2713 \u2713 <code>WithLimit</code> \u2713 \u2713 <code>WithOffset</code> \u2713 \u2713 <code>NewPage</code> \u2713 \u2713 <code>WithNResults</code> \u2713 <code>WithQueryTexts</code> \u2713 <code>WithTexts</code> \u2713 \u2713 <code>WithEmbeddings</code> \u2713 \u2713 <code>WithMetadatas</code> \u2713 \u2713 <code>WithIDGenerator</code> \u2713"},{"location":"#crud-operations","title":"CRUD Operations","text":""},{"location":"#add-documents","title":"Add Documents","text":"<pre><code>// Add with explicit IDs\nerr := col.Add(ctx,\n    chroma.WithIDs(\"id1\", \"id2\"),\n    chroma.WithTexts(\"First document\", \"Second document\"),\n    chroma.WithMetadatas(\n        map[string]any{\"author\": \"Alice\"},\n        map[string]any{\"author\": \"Bob\"},\n    ),\n)\n\n// Add with auto-generated IDs\nerr := col.Add(ctx,\n    chroma.WithTexts(\"Document without explicit ID\"),\n    chroma.WithIDGenerator(chroma.NewULIDGenerator()),\n)\n\n// Add with pre-computed embeddings\nerr := col.Add(ctx,\n    chroma.WithIDs(\"id1\"),\n    chroma.WithEmbeddings([]float32{0.1, 0.2, 0.3, ...}),\n    chroma.WithMetadatas(map[string]any{\"source\": \"external\"}),\n)\n</code></pre>"},{"location":"#get-documents","title":"Get Documents","text":"<pre><code>// Get by IDs\nresults, err := col.Get(ctx, chroma.WithIDs(\"id1\", \"id2\"))\n\n// Get with metadata filter\nresults, err := col.Get(ctx,\n    chroma.WithWhere(chroma.EqString(\"author\", \"Alice\")),\n    chroma.WithInclude(chroma.IncludeDocuments, chroma.IncludeMetadatas),\n)\n\n// Get with pagination\nresults, err := col.Get(ctx,\n    chroma.WithLimit(10),\n    chroma.WithOffset(20),\n)\n\n// Get with document content filter\nresults, err := col.Get(ctx,\n    chroma.WithWhereDocument(chroma.Contains(\"machine learning\")),\n)\n</code></pre>"},{"location":"#query-semantic-search","title":"Query (Semantic Search)","text":"<pre><code>// Basic query\nresults, err := col.Query(ctx,\n    chroma.WithQueryTexts(\"machine learning algorithms\"),\n    chroma.WithNResults(5),\n)\n\n// Query with metadata filter\nresults, err := col.Query(ctx,\n    chroma.WithQueryTexts(\"neural networks\"),\n    chroma.WithWhere(chroma.AndFilter(\n        chroma.EqString(\"category\", \"dl\"),\n        chroma.GtInt(\"year\", 2022),\n    )),\n    chroma.WithNResults(10),\n)\n\n// Query with multiple queries\nresults, err := col.Query(ctx,\n    chroma.WithQueryTexts(\"AI\", \"robotics\", \"automation\"),\n    chroma.WithNResults(3),\n)\n// results.GetIDsGroups()[0] - results for \"AI\"\n// results.GetIDsGroups()[1] - results for \"robotics\"\n// results.GetIDsGroups()[2] - results for \"automation\"\n</code></pre>"},{"location":"#update-documents","title":"Update Documents","text":"<pre><code>// Update document content\nerr := col.Update(ctx,\n    chroma.WithIDs(\"id1\"),\n    chroma.WithTexts(\"Updated document content\"),\n)\n\n// Update metadata\nerr := col.Update(ctx,\n    chroma.WithIDs(\"id1\", \"id2\"),\n    chroma.WithMetadatas(\n        map[string]any{\"status\": \"reviewed\"},\n        map[string]any{\"status\": \"reviewed\"},\n    ),\n)\n</code></pre>"},{"location":"#upsert-documents","title":"Upsert Documents","text":"<pre><code>// Insert or update documents\nerr := col.Upsert(ctx,\n    chroma.WithIDs(\"id1\", \"id2\"),\n    chroma.WithTexts(\"New or updated doc 1\", \"New or updated doc 2\"),\n    chroma.WithMetadatas(meta1, meta2),\n)\n</code></pre>"},{"location":"#delete-documents","title":"Delete Documents","text":"<pre><code>// Delete by IDs\nerr := col.Delete(ctx, chroma.WithIDs(\"id1\", \"id2\"))\n\n// Delete by metadata filter\nerr := col.Delete(ctx,\n    chroma.WithWhere(chroma.EqString(\"status\", \"archived\")),\n)\n\n// Delete by document content\nerr := col.Delete(ctx,\n    chroma.WithWhereDocument(chroma.Contains(\"DEPRECATED\")),\n)\n</code></pre>"},{"location":"#metadata-filters","title":"Metadata Filters","text":"<p>The library provides type-safe filter functions:</p> <pre><code>// Equality\nchroma.EqString(\"field\", \"value\")\nchroma.EqInt(\"count\", 10)\nchroma.EqFloat(\"score\", 0.95)\nchroma.EqBool(\"active\", true)\n\n// Not equal\nchroma.NeString(\"status\", \"deleted\")\n\n// Comparison (numeric and string)\nchroma.GtInt(\"year\", 2020)      // greater than\nchroma.GteInt(\"year\", 2020)     // greater than or equal\nchroma.LtFloat(\"score\", 0.5)    // less than\nchroma.LteFloat(\"score\", 0.5)   // less than or equal\n\n// Set operations\nchroma.InString(\"category\", \"ml\", \"ai\", \"dl\")\nchroma.NinInt(\"priority\", 1, 2)\n\n// Logical operators\nchroma.AndFilter(filter1, filter2, ...)\nchroma.OrFilter(filter1, filter2, ...)\n</code></pre>"},{"location":"#document-content-filters","title":"Document Content Filters","text":"<pre><code>// Contains substring\nchroma.Contains(\"machine learning\")\n\n// Does not contain\nchroma.NotContains(\"deprecated\")\n\n// Combine filters\nchroma.AndDocumentFilter(\n    chroma.Contains(\"neural\"),\n    chroma.NotContains(\"outdated\"),\n)\n</code></pre>"},{"location":"#search-api","title":"Search API","text":"<p>For advanced use cases, the Search API provides more control:</p> <pre><code>results, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"machine learning\")),\n        chroma.WithFilter(chroma.EqString(chroma.K(\"status\"), \"published\")),\n        chroma.NewPage(chroma.Limit(10)),\n        chroma.WithSelect(chroma.KDocument, chroma.KScore, chroma.K(\"author\")),\n    ),\n)\n\n// Access results\nfor _, row := range results.(*chroma.SearchResultImpl).Rows() {\n    fmt.Printf(\"ID: %s, Score: %f, Doc: %s\\n\", row.ID, row.Score, row.Document)\n}\n</code></pre> <p>See Search API documentation for more details.</p>"},{"location":"#embedding-functions","title":"Embedding Functions","text":"<p>The client supports multiple embedding providers. See Embeddings for the full list.</p> <pre><code>import \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n\n// Create embedding function\nef, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n\n// Use with collection\ncol, err := client.GetOrCreateCollection(ctx, \"my-collection\",\n    chroma.WithEmbeddingFunction(ef),\n)\n</code></pre>"},{"location":"#v1-api-deprecated","title":"V1 API (Deprecated)","text":"<p>V1 API Removed</p> <p>The V1 API has been removed in version <code>v0.3.0</code>. If you need V1 compatibility: <pre><code>go get github.com/amikos-tech/chroma-go@v0.2.5\n</code></pre></p>"},{"location":"auth/","title":"Authentication","text":"<p>Chroma supports multiple authentication methods. All methods work with both self-hosted and Chroma Cloud deployments.</p> <p>\ud83d\udcc1 Complete Examples: Find runnable authentication examples in the <code>examples/v2/auth</code> directory.</p>"},{"location":"auth/#api-v2-recommended","title":"API v2 (Recommended)","text":""},{"location":"auth/#basic-authentication","title":"Basic Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithAuth(v2.NewBasicAuthCredentialsProvider(\"admin\", \"password\")),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-bearer","title":"Token Authentication - Bearer","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithAuth(v2.NewTokenAuthCredentialsProvider(\"my-token\", v2.AuthorizationTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-x-chroma-token","title":"Token Authentication - X-Chroma-Token","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithAuth(v2.NewTokenAuthCredentialsProvider(\"my-token\", v2.XChromaTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#custom-headers","title":"Custom Headers","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    headers := map[string]string{\n        \"Authorization\": \"Bearer custom-token\",\n        \"X-Custom-Header\": \"custom-value\",\n    }\n\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithDefaultHeaders(headers),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-cloud-authentication","title":"Chroma Cloud Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewCloudClient(\n        v2.WithCloudAPIKey(\"your-api-key\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#api-v1-legacy","title":"API v1 (Legacy)","text":"<p>V1 API Deprecation Notice</p> <p>The V1 API has been removed in version <code>v0.3.0</code> and later. To use the examples below, pin your dependency to <code>v0.2.5</code> or earlier: <pre><code>go get github.com/amikos-tech/chroma-go@v0.2.5\n</code></pre></p>"},{"location":"auth/#basic-authentication_1","title":"Basic Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithAuth(types.NewBasicAuthCredentialsProvider(\"admin\", \"password\")),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-bearer_1","title":"Token Authentication - Bearer","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-token\", types.AuthorizationTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-x-chroma-token_1","title":"Token Authentication - X-Chroma-Token","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-token\", types.XChromaTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#custom-headers_1","title":"Custom Headers","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    headers := map[string]string{\n        \"Authorization\": \"Bearer custom-token\",\n        \"X-Custom-Header\": \"custom-value\",\n    }\n\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithDefaultHeaders(headers),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"client/","title":"Chroma Client","text":""},{"location":"client/#chroma-cloud-client-v020","title":"Chroma Cloud Client (v0.2.0+)","text":"<p>Options:</p> Options Usage Description Value Required CloudAPIKey <code>WithCloudAPIKey(\"api_key\")</code> Set Chroma Cloud API Key <code>string</code> Yes (default: uses <code>CHROMA_API_KEY</code> env var if available) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> Yes (default: uses <code>CHROMA_TENANT</code> env var if available) Database <code>WithDatabaseAndTenant(\"database\",\"tenant\")</code> The default database and tenant (overrides any tenant set with Tenant). Option precedence is observed! <code>string</code> Yes (default: uses <code>CHROMA_DATABASE</code> env var if available) ~~Debug~~ ~~<code>WithDebug()</code>~~ DEPRECATED ~~Enable debug mode~~ Use <code>WithLogger</code> with debug level instead <code>bool</code> No (deprecated - use WithLogger) Logger <code>WithLogger(logger)</code> Set a custom logger for HTTP request/response logging. See logging docs <code>logger.Logger</code> No (default: NoopLogger) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default HTTP headers for the client. These headers are sent with every request. <code>map[string]string</code> No (default: <code>nil</code>) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) Timeout <code>WithTimeout(time.Duration)</code> Set the timeout for the client. <code>time.Duration</code> No (default is the default HTTP client timeout duration) <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n    \"log\"\n)\n\nfunc main() {\n    c, err := chroma.NewHTTPClient(\n        chroma.WithCloudAPIKey(\"my-api-key\"),\n        chroma.WithDatabaseAndTenant(\"team-uuid\", \"my-database\"),\n        // chroma.WithDebug() is deprecated - use WithLogger instead for debug output\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    v, err := c.GetVersion(context.Background())\n    if err != nil {\n        log.Fatalf(\"Error getting version: %s \\n\", err)\n    }\n    fmt.Printf(\"Chroma API Version: %s \\n\", v)\n}\n</code></pre>"},{"location":"client/#chroma-client-v020","title":"Chroma Client (v0.2.0+)","text":"<p>Options:</p> Options Usage Description Value Required API Endpoint <code>WithBasePath(\"http://localhost:8000\")</code> The Chroma server base API. Non-empty valid URL string No (default: <code>http://localhost:8000</code>) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> No (default: <code>default_tenant</code>) Database <code>WithDatabaseAndTenant(\"database\",\"tenant\")</code> The default database to use. <code>string</code> No (default: <code>default_database</code>) ~~Debug~~ ~~<code>WithDebug()</code>~~ DEPRECATED ~~Enable debug mode~~ Use <code>WithLogger</code> with debug level instead <code>bool</code> No (deprecated - use WithLogger) Logger <code>WithLogger(logger)</code> Set a custom logger for HTTP request/response logging. See logging docs <code>logger.Logger</code> No (default: NoopLogger) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default HTTP headers for the client. These headers are sent with every request. <code>map[string]string</code> No (default: <code>nil</code>) SSL Cert <code>WithSSLCert(\"path/to/cert.pem\")</code> Set the path to the SSL certificate. valid path to SSL cert. No (default: Not Set) Insecure <code>WithInsecure()</code> Disable SSL certificate verification No (default: Not Set) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) Auth <code>WithAuth(v2.CredentialsProvider)</code> Set the authentication method. The default is <code>WithAuth(types.NewNoAuthCredentialsProvider())</code> <code>CredentialsProvider</code> No (default: <code>NoAuth</code>) Timeout <code>WithTimeout(time.Duration)</code> Set the timeout for the client. <code>time.Duration</code> No (default is the default HTTP client timeout duration) Transport <code>WithTransport(*http.Transport)</code> Set the transport for the client. <code>http.RoundTripper</code> No (default: Default HTTPClient) <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n    \"log\"\n)\n\nfunc main() {\n    c, err := chroma.NewHTTPClient(\n        chroma.WithBaseURL(\"http://localhost:8000\"),\n        chroma.WithDatabaseAndTenant(\"default_database\", \"default_tenant\"),\n        chroma.WithDefaultHeaders(map[string]string{\"X-Custom-Header\": \"header-value\"}),\n        // chroma.WithDebug() is deprecated - use WithLogger instead for debug output\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    v, err := c.GetVersion(context.Background())\n    if err != nil {\n        log.Fatalf(\"Error getting version: %s \\n\", err)\n    }\n    fmt.Printf(\"Chroma API Version: %s \\n\", v)\n}\n</code></pre>"},{"location":"client/#client-version-v014-or-lower","title":"Client version v0.1.4 or lower","text":"<p>V1 API Deprecation Notice</p> <p>The V1 API has been removed in version <code>v0.3.0</code> and later. To use the examples below, pin your dependency to <code>v0.2.5</code> or earlier: <pre><code>go get github.com/amikos-tech/chroma-go@v0.2.5\n</code></pre></p> <p>Options:</p> Options Usage Description Value Required basePath <code>WithBasePath(\"http://localhost:8000\")</code> The Chroma server base API. Non-empty valid URL string No (default: <code>http://localhost:8000</code>) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> No (default: <code>default_tenant</code>) Database <code>WithDatabase(\"database\")</code> The default database to use. <code>string</code> No (default: <code>default_database</code>) ~~Debug~~ ~~<code>WithDebug()</code>~~ DEPRECATED ~~Enable debug mode~~ Use <code>WithLogger</code> with debug level instead <code>bool</code> No (deprecated - use WithLogger) Logger <code>WithLogger(logger)</code> Set a custom logger for HTTP request/response logging. See logging docs <code>logger.Logger</code> No (default: NoopLogger) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default headers for the client. <code>map[string]string</code> No (default: <code>nil</code>) SSL Cert <code>WithSSLCert(\"path/to/cert.pem\")</code> Set the path to the SSL certificate. valid path to SSL cert. No (default: Not Set) Insecure <code>WithInsecure()</code> Disable SSL certificate verification No (default: Not Set) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) <p>Tenant and Database</p> <p>The tenant and database are only supported for Chroma API version <code>0.4.15+</code>.</p> <p>Creating a new client:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithTenant(\"my_tenant\"),\n        chroma.WithDatabase(\"my_db\"),\n        // chroma.WithDebug(true) is deprecated - use WithLogger instead for debug output\n        chroma.WithDefaultHeaders(map[string]string{\"Authorization\": \"Bearer my token\"}),\n        chroma.WithSSLCert(\"path/to/cert.pem\"),\n    )\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n    // do something with client\n\n    // Close the client to release any resources such as local embedding functions\n    err = client.Close()\n    if err != nil {\n        fmt.Printf(\"Failed to close client: %v\", err)\n    }\n}\n</code></pre>"},{"location":"cloud-features/","title":"Cloud Features","text":"<p>This page documents features that are only available in Chroma Cloud.</p>"},{"location":"cloud-features/#indexing-status","title":"Indexing Status","text":"<p>Chroma Cloud uses a write-ahead log (WAL) to durably store writes before compacting them into the index. The Indexing Status API lets you check how much of the WAL has been indexed.</p> <p>Cloud Only</p> <p>This feature requires Chroma Cloud with version &gt;= 1.4.1</p>"},{"location":"cloud-features/#usage","title":"Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewCloudClient(\n        v2.WithCloudAPIKey(\"your-api-key\"),\n        v2.WithDatabaseAndTenant(\"your-database\", \"your-tenant\"),\n    )\n    if err != nil {\n        log.Fatalf(\"Error: %v\", err)\n    }\n    defer client.Close()\n\n    ctx := context.Background()\n\n    collection, err := client.GetCollection(ctx, \"my_collection\")\n    if err != nil {\n        log.Fatalf(\"Error: %v\", err)\n    }\n\n    status, err := collection.IndexingStatus(ctx)\n    if err != nil {\n        log.Fatalf(\"Error: %v\", err)\n    }\n\n    fmt.Printf(\"Total operations: %d\\n\", status.TotalOps)\n    fmt.Printf(\"Indexed operations: %d\\n\", status.NumIndexedOps)\n    fmt.Printf(\"Unindexed operations: %d\\n\", status.NumUnindexedOps)\n    fmt.Printf(\"Progress: %.1f%%\\n\", status.OpIndexingProgress*100)\n}\n</code></pre>"},{"location":"cloud-features/#indexingstatus-response","title":"IndexingStatus Response","text":"Field Type Description <code>NumIndexedOps</code> <code>uint64</code> Number of operations compacted into the index <code>NumUnindexedOps</code> <code>uint64</code> Number of operations still in the WAL <code>TotalOps</code> <code>uint64</code> Total number of operations <code>OpIndexingProgress</code> <code>float64</code> Progress from 0.0 to 1.0"},{"location":"cloud-features/#use-cases","title":"Use Cases","text":"<ul> <li>Monitor batch ingestion: Track progress when loading large datasets</li> <li>Optimize read levels: Use <code>ReadLevelIndexOnly</code> when indexing is complete for faster queries</li> <li>Wait for data availability: Ensure recently added data is searchable before querying</li> </ul>"},{"location":"cloud-features/#integration-with-read-levels","title":"Integration with Read Levels","text":"<pre><code>status, err := collection.IndexingStatus(ctx)\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\nvar readLevel v2.ReadLevel\nif status.OpIndexingProgress &gt;= 1.0 {\n    // All data indexed - use faster index-only reads\n    readLevel = v2.ReadLevelIndexOnly\n} else {\n    // Some data not indexed - read from WAL to see all data\n    readLevel = v2.ReadLevelIndexAndWAL\n}\n\nresults, err := collection.Search(ctx,\n    v2.NewSearchRequest(\n        v2.WithKnnRank(v2.KnnQueryText(\"machine learning\")),\n        v2.NewPage(v2.Limit(10)),\n    ),\n    v2.WithReadLevel(readLevel),\n)\n</code></pre> <p>For more examples, see Indexing Status Go Examples.</p>"},{"location":"cloud-features/#collection-forking","title":"Collection Forking","text":"<p>Forking lets you create a new collection from an existing one instantly using copy-on-write.</p> <p>Cloud Only</p> <p>Collection forking is available in Chroma Cloud only.</p> <pre><code>// Get source collection\nsourceCollection, err := client.GetCollection(ctx, \"main-repo-index\")\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\n// Create a forked collection\nforkedCollection, err := sourceCollection.Fork(ctx, \"main-repo-index-pr-1234\")\nif err != nil {\n    log.Fatalf(\"Error: %v\", err)\n}\n\n// Forked collection is immediately queryable\nerr = forkedCollection.Add(ctx,\n    v2.WithIDs(\"doc-pr-1\"),\n    v2.WithTexts(\"new content\"),\n)\n</code></pre> <p>For more examples, see Collection Forking Go Examples.</p>"},{"location":"embeddings/","title":"Embedding Models","text":"<p>The following embedding wrappers are available:</p> Embedding Model Description Default Embeddings The default Chroma embedding function running <code>all-MiniLM-L6-v2</code> on Onnx Runtime OpenAI OpenAI embeddings API.All models are supported - see OpenAI docs for more info. Cohere Cohere embeddings API.All models are supported - see Cohere API docs for more info. HuggingFace Inference API HuggingFace Inference API.All models supported by the API. HuggingFace Embedding Inference Server HuggingFace Embedding Inference Server.Models supported by the inference server. Ollama Ollama embeddings API.All models are supported - see Ollama models lib for more info. Cloudflare Workers AI Cloudflare Workers AI Embedding. For more info see CF API Docs. Together AI Together AI Embedding. For more info see Together API Docs. Voyage AI Voyage AI Embedding. For more info see Together API Docs. Google Gemini Google Gemini Embedding. For more info see Gemini Docs. Mistral AI Mistral AI Embedding. For more info see Mistral AI API Docs. Nomic AI Nomic AI Embedding. For more info see Nomic AI API Docs. Jina AI Jina AI Embedding. For more info see Nomic AI API Docs."},{"location":"embeddings/#default-embeddings","title":"Default Embeddings","text":"<p>Note: Supported from 0.2.0+</p> <p>The default embedding function uses the <code>all-MiniLM-L6-v2</code> model running on Onnx Runtime. The default EF is configured by default if no EF is provided when creating or getting a collection.</p> <p>Note: As the EF relies on C bindings to avoid memory leaks make sure to call the close callback, alternatively if you are passing the EF to a client e.g. when getting or creating a collection you can use the client's close method to ensure proper resource release.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    defaultef \"github.com/amikos-tech/chroma-go/pkg/embeddings/default_ef\"\n)\n\nfunc main() {\n    ef, closeef, efErr := defaultef.NewDefaultEmbeddingFunction()\n\n    // make sure to call this to ensure proper resource release\n    defer func() {\n        err := closeef()\n        if err != nil {\n            fmt.Printf(\"Error closing default embedding function: %s \\n\", err)\n        }\n    }()\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#onnx-runtime-configuration","title":"ONNX Runtime Configuration","text":"<p>The ONNX Runtime library can be customized using environment variables:</p> <ul> <li><code>CHROMAGO_ONNX_RUNTIME_PATH</code> - Absolute path to a custom ONNX Runtime library file (e.g., <code>/usr/local/lib/libonnxruntime.1.23.2.dylib</code>). When set, skips auto-download.</li> <li><code>CHROMAGO_ONNX_RUNTIME_VERSION</code> - Version of ONNX Runtime to download (default: <code>1.22.0</code>). Only used when <code>CHROMAGO_ONNX_RUNTIME_PATH</code> is not set.</li> </ul> <p>Example: <pre><code># Use a specific version\nexport CHROMAGO_ONNX_RUNTIME_VERSION=1.23.0\n\n# Or point to a manually downloaded library\nexport CHROMAGO_ONNX_RUNTIME_PATH=/usr/local/lib/libonnxruntime.1.23.2.dylib\n</code></pre></p>"},{"location":"embeddings/#openai","title":"OpenAI","text":"<p>Supported Embedding Function Options:</p> <ul> <li><code>WithModel</code> - Set the OpenAI model to use. Default is <code>TextEmbeddingAda002</code> (<code>text-embedding-ada-002</code>).</li> <li><code>WithBaseURL</code> - Set the OpenAI base URL. Default is <code>https://api.openai.com/v1</code>. This allows you to point the EF to a   compatible OpenAI API endpoint.</li> <li><code>WithDimensions</code> - Set the number of dimensions for the embeddings. Default is <code>None</code> which returns the full   embeddings.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    openai \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ef, efErr := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"), openai.WithModel(openai.TextEmbedding3Large))\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cohere","title":"Cohere","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    cohere \"github.com/amikos-tech/chroma-go/pkg/embeddings/cohere\"\n)\n\nfunc main() {\n    ef := cohere.NewCohereEmbeddingFunction(os.Getenv(\"COHERE_API_KEY\"))\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-inference-api","title":"HuggingFace Inference API","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/pkg/embeddings/hf\"\n)\n\nfunc main() {\n    ef := huggingface.NewHuggingFaceEmbeddingFunction(os.Getenv(\"HUGGINGFACE_API_KEY\"), \"sentence-transformers/all-MiniLM-L6-v2\")\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-embedding-inference-server","title":"HuggingFace Embedding Inference Server","text":"<p>The embedding server allows you to run supported model locally on your machine with CPU and GPU inference. For more information check the HuggingFace Embedding Inference Server repository.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/hf\"\n)\n\nfunc main() {\n    ef, err := huggingface.NewHuggingFaceEmbeddingInferenceFunction(\"http://localhost:8001/embed\") //set this to the URL of the HuggingFace Embedding Inference Server\n    if err != nil {\n        fmt.Printf(\"Error creating HuggingFace embedding function: %s \\n\", err)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#ollama","title":"Ollama","text":"<p>Assumptions</p> <p>The below example assumes that you have an Ollama server running locally on <code>http://127.0.0.1:11434</code>.</p> <p>Use the following command to start the Ollama server:</p> <pre><code>    docker run -d -v ./ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama\n    docker exec -it ollama ollama run nomic-embed-text # press Ctrl+D to exit after model downloads successfully\n    # test it\n    curl http://localhost:11434/api/embed -d '{\"model\": \"nomic-embed-text\",\"input\": [\"Here is an article about llamas...\"]}'\n ```\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    ollama \"github.com/amikos-tech/chroma-go/pkg/embeddings/ollama\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // the `/api/embeddings` endpoint is automatically appended to the base URL\n    ef, err := ollama.NewOllamaEmbeddingFunction(ollama.WithBaseURL(\"http://127.0.0.1:11434\"), ollama.WithModel(\"nomic-embed-text\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Ollama embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cloudflare-workers-ai","title":"Cloudflare Workers AI","text":"<p>You will need to register for a Cloudflare account and create a API Token for Workers AI - see docs for more info.</p> <p>Models can be found in the Cloudflare Workers AI docs. <code>@cf/baai/bge-base-en-v1.5</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    cf \"github.com/amikos-tech/chroma-go/pkg/embeddings/cloudflare\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `CF_API_TOKEN` and `CF_ACCOUNT_ID` set in your environment\n    ef, err := cf.NewCloudflareEmbeddingFunction(cf.WithEnvAPIToken(), cf.WithEnvAccountID(), cf.WithDefaultModel(\"@cf/baai/bge-small-en-v1.5\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Cloudflare embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#together-ai","title":"Together AI","text":"<p>To use Together AI embeddings, you will need to register for a Together AI account and create an API Key.</p> <p>Available models can be in Together AI docs. <code>togethercomputer/m2-bert-80M-8k-retrieval</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/together\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `TOGETHER_API_KEY` set in your environment\n    ef, err := t.NewTogetherEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"togethercomputer/m2-bert-80M-2k-retrieval\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#voyage-ai","title":"Voyage AI","text":"<p>To use Voyage AI embeddings, you will need to register for a Voyage AI account and create an API Key.</p> <p>Available models can be in Voyage AI docs. <code>voyage-2</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/voyage\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `VOYAGE_API_KEY` set in your environment\n    ef, err := t.NewVoyageAIEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"voyage-large-2\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#google-gemini","title":"Google Gemini","text":"<p>To use Google Gemini AI embeddings, you will need to create an API Key.</p> <p>Available models can be in Gemini Models. <code>text-embedding-004</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    g \"github.com/amikos-tech/chroma-go/pkg/embeddings/gemini\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `GEMINI_API_KEY` set in your environment\n    ef, err := g.NewGeminiEmbeddingFunction(g.WithEnvAPIKey(), g.WithDefaultModel(\"text-embedding-004\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Gemini embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#mistral-ai","title":"Mistral AI","text":"<p>To use Mistral AI embeddings, you will need to create an API Key.</p> <p>Currently, (as of July 2024) only <code>mistral-embed</code> model is available, which is the default model we use.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    mistral \"github.com/amikos-tech/chroma-go/pkg/embeddings/mistral\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `MISTRAL_API_KEY` set in your environment\n    ef, err := mistral.NewMistralEmbeddingFunction(mistral.WithEnvAPIKey(), mistral.WithDefaultModel(\"mistral-embed\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Mistral embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#nomic-ai","title":"Nomic AI","text":"<p>To use Nomic AI embeddings, you will need to create an API Key.</p> <p>Supported models - https://docs.nomic.ai/atlas/models/text-embedding</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    nomic \"github.com/amikos-tech/chroma-go/pkg/embeddings/nomic\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `NOMIC_API_KEY` set in your environment\n    ef, err := nomic.NewNomicEmbeddingFunction(nomic.WithEnvAPIKey(), nomic.WithDefaultModel(nomic.NomicEmbedTextV1))\n    if err != nil {\n        fmt.Printf(\"Error creating Nomic embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#jina-ai","title":"Jina AI","text":"<p>To use Jina AI embeddings, you will need to get an API Key (trial API keys are freely available without any registration, scroll down the page and find the automatically generated API key).</p> <p>Supported models - https://api.jina.ai/redoc#tag/embeddings/operation/create_embedding_v1_embeddings_post</p> <p>Supported Embedding Function Options:</p> <ul> <li><code>WithModel</code> - Set the Jina model to use. Default is <code>jina-embeddings-v3</code>.</li> <li><code>WithTask</code> - Set the task type (<code>retrieval.query</code>, <code>retrieval.passage</code>, <code>classification</code>, <code>text-matching</code>, <code>separation</code>).</li> <li><code>WithNormalized</code> - Whether to normalize (L2 norm) the output embeddings. Default is <code>true</code>.</li> <li><code>WithLateChunking</code> - Enable late chunking mode which concatenates all sentences and treats them as a single input for contextual token-level embeddings. Default is <code>false</code>.</li> <li><code>WithEmbeddingEndpoint</code> - Set a custom API endpoint.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    jina \"github.com/amikos-tech/chroma-go/pkg/embeddings/jina\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `JINA_API_KEY` set in your environment\n    ef, err := jina.NewJinaEmbeddingFunction(\n        jina.WithEnvAPIKey(),\n        jina.WithTask(jina.TaskTextMatching),\n        jina.WithLateChunking(true),\n    )\n    if err != nil {\n        fmt.Printf(\"Error creating Jina embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"filtering/","title":"Filtering","text":"<p>Chroma Go provides powerful filtering capabilities for Get, Query, Delete, and Search operations.</p>"},{"location":"filtering/#unified-filter-options","title":"Unified Filter Options","text":"<p>The V2 API uses unified options that work across multiple operations:</p> Option Get Query Delete Search <code>WithWhere</code> \u2713 \u2713 \u2713 <code>WithWhereDocument</code> \u2713 \u2713 \u2713 <code>WithIDs</code> \u2713 \u2713 \u2713 \u2713 <code>WithFilter</code> \u2713"},{"location":"filtering/#metadata-filters","title":"Metadata Filters","text":"<p>Filter documents based on metadata field values using type-safe filter functions.</p>"},{"location":"filtering/#equality-operators","title":"Equality Operators","text":"<pre><code>import chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n\n// String equality\nchroma.EqString(\"status\", \"active\")\nchroma.NeString(\"status\", \"deleted\")\n\n// Integer equality\nchroma.EqInt(\"count\", 10)\nchroma.NeInt(\"priority\", 0)\n\n// Float equality\nchroma.EqFloat(\"score\", 0.95)\nchroma.NeFloat(\"threshold\", 0.5)\n\n// Boolean equality\nchroma.EqBool(\"published\", true)\nchroma.NeBool(\"draft\", false)\n</code></pre>"},{"location":"filtering/#comparison-operators","title":"Comparison Operators","text":"<pre><code>// Greater than\nchroma.GtInt(\"year\", 2020)\nchroma.GtFloat(\"score\", 0.8)\nchroma.GtString(\"name\", \"A\")  // lexicographic\n\n// Greater than or equal\nchroma.GteInt(\"version\", 2)\nchroma.GteFloat(\"rating\", 4.0)\n\n// Less than\nchroma.LtInt(\"age\", 30)\nchroma.LtFloat(\"price\", 100.0)\n\n// Less than or equal\nchroma.LteInt(\"priority\", 5)\nchroma.LteFloat(\"discount\", 0.25)\n</code></pre>"},{"location":"filtering/#set-operators","title":"Set Operators","text":"<pre><code>// Value in set\nchroma.InString(\"category\", \"ml\", \"ai\", \"dl\")\nchroma.InInt(\"priority\", 1, 2, 3)\nchroma.InFloat(\"score\", 0.9, 0.95, 1.0)\n\n// Value not in set\nchroma.NinString(\"status\", \"deleted\", \"archived\")\nchroma.NinInt(\"level\", 0, 1)\n</code></pre>"},{"location":"filtering/#logical-operators","title":"Logical Operators","text":"<pre><code>// AND - all conditions must match\nchroma.AndFilter(\n    chroma.EqString(\"category\", \"tech\"),\n    chroma.GtInt(\"year\", 2020),\n    chroma.EqBool(\"published\", true),\n)\n\n// OR - any condition can match\nchroma.OrFilter(\n    chroma.EqString(\"author\", \"Alice\"),\n    chroma.EqString(\"author\", \"Bob\"),\n)\n\n// Nested logic\nchroma.AndFilter(\n    chroma.EqString(\"status\", \"published\"),\n    chroma.OrFilter(\n        chroma.EqString(\"category\", \"tech\"),\n        chroma.EqString(\"category\", \"science\"),\n    ),\n)\n</code></pre>"},{"location":"filtering/#document-content-filters","title":"Document Content Filters","text":"<p>Filter documents based on their text content.</p> <pre><code>// Contains substring\nchroma.Contains(\"machine learning\")\n\n// Does not contain substring\nchroma.NotContains(\"deprecated\")\n\n// Combine with AND\nchroma.AndDocumentFilter(\n    chroma.Contains(\"neural network\"),\n    chroma.NotContains(\"outdated\"),\n)\n\n// Combine with OR\nchroma.OrDocumentFilter(\n    chroma.Contains(\"Python\"),\n    chroma.Contains(\"Go\"),\n)\n</code></pre>"},{"location":"filtering/#usage-examples","title":"Usage Examples","text":""},{"location":"filtering/#get-with-filters","title":"Get with Filters","text":"<pre><code>// Get by metadata\nresults, err := col.Get(ctx,\n    chroma.WithWhere(chroma.EqString(\"author\", \"Alice\")),\n    chroma.WithInclude(chroma.IncludeDocuments, chroma.IncludeMetadatas),\n)\n\n// Get by document content\nresults, err := col.Get(ctx,\n    chroma.WithWhereDocument(chroma.Contains(\"machine learning\")),\n)\n\n// Combine metadata and document filters\nresults, err := col.Get(ctx,\n    chroma.WithWhere(chroma.GtInt(\"year\", 2022)),\n    chroma.WithWhereDocument(chroma.NotContains(\"draft\")),\n)\n</code></pre>"},{"location":"filtering/#query-with-filters","title":"Query with Filters","text":"<pre><code>// Semantic search with metadata filter\nresults, err := col.Query(ctx,\n    chroma.WithQueryTexts(\"neural networks\"),\n    chroma.WithWhere(chroma.AndFilter(\n        chroma.EqString(\"category\", \"deep-learning\"),\n        chroma.EqBool(\"peer_reviewed\", true),\n    )),\n    chroma.WithNResults(10),\n)\n\n// Query with document content filter\nresults, err := col.Query(ctx,\n    chroma.WithQueryTexts(\"transformers\"),\n    chroma.WithWhereDocument(chroma.Contains(\"attention mechanism\")),\n    chroma.WithNResults(5),\n)\n\n// Limit search to specific IDs\nresults, err := col.Query(ctx,\n    chroma.WithQueryTexts(\"optimization\"),\n    chroma.WithIDs(\"paper1\", \"paper2\", \"paper3\"),\n    chroma.WithNResults(2),\n)\n</code></pre>"},{"location":"filtering/#delete-with-filters","title":"Delete with Filters","text":"<pre><code>// Delete by IDs\nerr := col.Delete(ctx, chroma.WithIDs(\"id1\", \"id2\"))\n\n// Delete by metadata\nerr := col.Delete(ctx,\n    chroma.WithWhere(chroma.EqString(\"status\", \"archived\")),\n)\n\n// Delete by document content\nerr := col.Delete(ctx,\n    chroma.WithWhereDocument(chroma.Contains(\"DEPRECATED\")),\n)\n\n// Delete with combined filters\nerr := col.Delete(ctx,\n    chroma.WithWhere(chroma.LtInt(\"year\", 2020)),\n    chroma.WithWhereDocument(chroma.NotContains(\"classic\")),\n)\n</code></pre>"},{"location":"filtering/#search-api-filters","title":"Search API Filters","text":"<p>The Search API uses a slightly different filter syntax with the <code>K()</code> function:</p> <pre><code>// Basic filter\nresults, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"query\")),\n        chroma.WithFilter(chroma.EqString(chroma.K(\"status\"), \"published\")),\n    ),\n)\n\n// Complex filter\nresults, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"machine learning\")),\n        chroma.WithFilter(chroma.And(\n            chroma.EqString(chroma.K(\"category\"), \"research\"),\n            chroma.GtInt(chroma.K(\"citations\"), 100),\n            chroma.Or(\n                chroma.EqString(chroma.K(\"venue\"), \"NeurIPS\"),\n                chroma.EqString(chroma.K(\"venue\"), \"ICML\"),\n            ),\n        )),\n        chroma.NewPage(chroma.Limit(20)),\n    ),\n)\n\n// Filter by IDs\nresults, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"query\")),\n        chroma.WithIDs(\"doc1\", \"doc2\", \"doc3\"),\n    ),\n)\n</code></pre>"},{"location":"filtering/#deprecated-functions","title":"Deprecated Functions","text":"<p>The following operation-specific functions are deprecated. Use the unified options instead:</p> Deprecated Replacement <code>WithIDsGet</code> <code>WithIDs</code> <code>WithIDsQuery</code> <code>WithIDs</code> <code>WithIDsUpdate</code> <code>WithIDs</code> <code>WithIDsDelete</code> <code>WithIDs</code> <code>WithWhereGet</code> <code>WithWhere</code> <code>WithWhereQuery</code> <code>WithWhere</code> <code>WithWhereDelete</code> <code>WithWhere</code> <code>WithWhereDocumentGet</code> <code>WithWhereDocument</code> <code>WithWhereDocumentQuery</code> <code>WithWhereDocument</code> <code>WithWhereDocumentDelete</code> <code>WithWhereDocument</code> <code>WithIncludeGet</code> <code>WithInclude</code> <code>WithIncludeQuery</code> <code>WithInclude</code> <code>WithLimitGet</code> <code>WithLimit</code> <code>WithOffsetGet</code> <code>WithOffset</code> <code>WithTextsUpdate</code> <code>WithTexts</code> <code>WithMetadatasUpdate</code> <code>WithMetadatas</code> <code>WithEmbeddingsUpdate</code> <code>WithEmbeddings</code> <code>WithFilterIDs</code> <code>WithIDs</code> <code>WithPage</code> <code>NewPage</code> <code>PageLimit</code> <code>Limit</code> <code>PageOffset</code> <code>Offset</code>"},{"location":"logging/","title":"Logging","text":"<p>V2 API Only</p> <p>The logging feature is only available for the V2 API. V1 API uses standard library logging and is maintained for backward compatibility.</p>"},{"location":"logging/#overview","title":"Overview","text":"<p>The chroma-go V2 client provides a flexible logging interface that allows you to inject custom loggers instead of using stdio for debug output. This feature enables better integration with your application's logging infrastructure and provides structured logging capabilities.</p>"},{"location":"logging/#features","title":"Features","text":"<ul> <li>Pluggable Logger Interface: Define your own logger implementation or use the provided ones</li> <li>Structured Logging: Support for structured fields and context-aware logging</li> <li>Multiple Log Levels: Debug, Info, Warn, and Error levels</li> <li>Context Support: Pass context for distributed tracing and request correlation</li> <li>Zero Allocation: NoopLogger for production scenarios where logging should be disabled</li> </ul>"},{"location":"logging/#logger-interface","title":"Logger Interface","text":"<p>The Logger interface defines the contract for all logger implementations:</p> <pre><code>type Logger interface {\n    // Standard logging methods\n    Debug(msg string, fields ...Field)\n    Info(msg string, fields ...Field)\n    Warn(msg string, fields ...Field)\n    Error(msg string, fields ...Field)\n\n    // Context-aware logging methods\n    DebugWithContext(ctx context.Context, msg string, fields ...Field)\n    InfoWithContext(ctx context.Context, msg string, fields ...Field)\n    WarnWithContext(ctx context.Context, msg string, fields ...Field)\n    ErrorWithContext(ctx context.Context, msg string, fields ...Field)\n\n    // With returns a new logger with the given fields\n    With(fields ...Field) Logger\n\n    // Enabled returns true if the given level is enabled\n    IsDebugEnabled() bool\n}\n</code></pre>"},{"location":"logging/#built-in-implementations","title":"Built-in Implementations","text":""},{"location":"logging/#zaplogger","title":"ZapLogger","text":"<p>The ZapLogger wraps uber-go/zap for high-performance structured logging.</p> <pre><code>import (\n    \"go.uber.org/zap\"\n    chromalogger \"github.com/amikos-tech/chroma-go/pkg/logger\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\n// Create a zap logger\nzapLogger, _ := zap.NewProduction()\n\n// Wrap it in ChromaLogger\nlogger := chromalogger.NewZapLogger(zapLogger)\n\n// Use it with the client\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre>"},{"location":"logging/#development-logger","title":"Development Logger","text":"<p>For development, you can use a pre-configured development logger:</p> <pre><code>logger, _ := chromalogger.NewDevelopmentZapLogger()\n\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre>"},{"location":"logging/#nooplogger","title":"NoopLogger","text":"<p>The NoopLogger discards all log messages and is useful for production scenarios where you want to disable logging completely:</p> <pre><code>logger := chromalogger.NewNoopLogger()\n\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre>"},{"location":"logging/#using-withdebug-deprecated","title":"Using WithDebug() (DEPRECATED)","text":"<p>\u26a0\ufe0f DEPRECATED: <code>WithDebug()</code> is deprecated and will be removed in a future version. Use <code>WithLogger()</code> with a debug-level logger instead.</p> <pre><code>// DEPRECATED - Do not use\n// client, err := v2.NewHTTPClient(\n//     v2.WithBaseURL(\"http://localhost:8000\"),\n//     v2.WithDebug(),\n// )\n\n// RECOMMENDED - Use WithLogger instead\nlogger, _ := chromalogger.NewDevelopmentZapLogger()\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger), // Provides debug-level logging\n)\n</code></pre>"},{"location":"logging/#structured-logging-with-fields","title":"Structured Logging with Fields","text":"<p>The logger supports structured logging with fields for better log analysis:</p> <pre><code>logger := chromalogger.NewDevelopmentZapLogger()\n\n// Create a logger with persistent fields\nrequestLogger := logger.With(\n    chromalogger.String(\"request_id\", \"123\"),\n    chromalogger.String(\"user_id\", \"user-456\"),\n)\n\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(requestLogger),\n)\n</code></pre>"},{"location":"logging/#field-helpers","title":"Field Helpers","text":"<p>The logger package provides convenient field constructors:</p> <pre><code>chromalogger.String(\"key\", \"value\")\nchromalogger.Int(\"count\", 42)\nchromalogger.Bool(\"enabled\", true)\nchromalogger.ErrorField(\"error\", err)\nchromalogger.Any(\"data\", complexObject)\n</code></pre>"},{"location":"logging/#context-aware-logging","title":"Context-Aware Logging","text":"<p>For distributed tracing and request correlation, use the context-aware methods:</p> <pre><code>ctx := context.WithValue(context.Background(), \"trace-id\", \"abc123\")\n\n// The logger implementation can extract values from context\nlogger.InfoWithContext(ctx, \"Processing request\",\n    chromalogger.String(\"operation\", \"query\"),\n)\n</code></pre>"},{"location":"logging/#custom-logger-implementation","title":"Custom Logger Implementation","text":"<p>You can implement your own logger by implementing the Logger interface:</p> <pre><code>type MyCustomLogger struct {\n    // your logger implementation\n}\n\nfunc (l *MyCustomLogger) Debug(msg string, fields ...chromalogger.Field) {\n    // implement debug logging\n}\n\nfunc (l *MyCustomLogger) Info(msg string, fields ...chromalogger.Field) {\n    // implement info logging\n}\n\n// ... implement other required methods\n\n// Use your custom logger\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(&amp;MyCustomLogger{}),\n)\n</code></pre>"},{"location":"logging/#cloud-client-support","title":"Cloud Client Support","text":"<p>The logging feature is also available for the Cloud client:</p> <pre><code>logger := chromalogger.NewDevelopmentZapLogger()\n\nclient, err := v2.NewCloudClient(\n    v2.WithLogger(logger),\n    v2.WithCloudAPIKey(\"your-api-key\"),\n    v2.WithDatabaseAndTenant(\"database\", \"tenant\"),\n)\n</code></pre>"},{"location":"logging/#security-considerations","title":"Security Considerations","text":"<p>Sensitive Information in Debug Logs</p> <p>When debug logging is enabled, the client logs full HTTP request and response dumps which may contain sensitive information. Use debug logging with caution, especially in production environments.</p>"},{"location":"logging/#what-information-may-be-exposed","title":"What Information May Be Exposed","text":"<p>When debug logging is enabled, the following sensitive information may appear in logs:</p> <ol> <li> <p>Tenant IDs and Database Names: In Cloud client requests, URLs contain tenant UUIDs and database names that are logged in plaintext:    <pre><code>POST /api/v2/tenants/&lt;tenant_uuid&gt;/databases/&lt;database_name&gt;/collections HTTP/1.1\n</code></pre></p> </li> <li> <p>Request/Response Bodies: Full request and response payloads are logged, which may contain:</p> </li> <li>Collection names and metadata</li> <li>Document content and embeddings</li> <li> <p>Query parameters and filters</p> </li> <li> <p>Authentication Tokens: While authentication tokens (Bearer tokens, API keys, Basic auth) are automatically obfuscated in logs, the obfuscation shows partial token content which may still be considered sensitive.</p> </li> </ol>"},{"location":"logging/#recommendations","title":"Recommendations","text":"<ol> <li>Production Environments:</li> <li>Use <code>NoopLogger</code> in production to completely disable logging</li> <li> <p>If logging is required, avoid debug level and use info/warn/error levels only</p> </li> <li> <p>Development and Testing:</p> </li> <li>Be aware that debug logs may contain sensitive data</li> <li>Avoid committing log files to version control</li> <li> <p>Clear log files after debugging sessions</p> </li> <li> <p>Shared Environments:</p> </li> <li>Consider who has access to log files when enabling debug logging</li> <li>Implement log rotation and secure log storage practices</li> <li>Redact sensitive information from logs before sharing for support</li> </ol>"},{"location":"logging/#example-safe-production-configuration","title":"Example: Safe Production Configuration","text":"<pre><code>// Production: Use NoopLogger to disable all logging\nlogger := chromalogger.NewNoopLogger()\n\n// Or use a production logger with INFO level or higher\nzapConfig := zap.NewProductionConfig()\nzapConfig.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel) // No debug logs\nzapLogger, _ := zapConfig.Build()\nlogger := chromalogger.NewZapLogger(zapLogger)\n\nclient, err := v2.NewCloudClient(\n    v2.WithLogger(logger),\n    v2.WithCloudAPIKey(\"your-api-key\"),\n    v2.WithDatabaseAndTenant(\"database\", \"tenant\"),\n)\n</code></pre>"},{"location":"logging/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Use NoopLogger in Production: If you don't need logging, use NoopLogger to avoid any performance overhead</li> <li>Check IsDebugEnabled(): Before expensive debug operations, check if debug logging is enabled</li> <li>Use Structured Fields: Instead of string formatting, use structured fields for better performance</li> <li>Reuse Loggers: Create loggers with common fields using <code>With()</code> and reuse them</li> </ol>"},{"location":"logging/#example-complete-logging-setup","title":"Example: Complete Logging Setup","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"go.uber.org/zap\"\n    \"go.uber.org/zap/zapcore\"\n\n    chromalogger \"github.com/amikos-tech/chroma-go/pkg/logger\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    // Configure zap logger\n    config := zap.NewProductionConfig()\n    config.Level = zap.NewAtomicLevelAt(zapcore.DebugLevel)\n    config.OutputPaths = []string{\"stdout\", \"/var/log/chroma-client.log\"}\n\n    zapLogger, err := config.Build()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer zapLogger.Sync()\n\n    // Create chroma logger\n    logger := chromalogger.NewZapLogger(zapLogger)\n\n    // Add request-specific fields\n    requestLogger := logger.With(\n        chromalogger.String(\"service\", \"my-app\"),\n        chromalogger.String(\"version\", \"1.0.0\"),\n    )\n\n    // Create client with logger\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithLogger(requestLogger),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Use the client - all operations will be logged\n    ctx := context.Background()\n    collections, err := client.ListCollections(ctx)\n    if err != nil {\n        requestLogger.Error(\"Failed to list collections\",\n            chromalogger.ErrorField(\"error\", err),\n        )\n        return\n    }\n\n    requestLogger.Info(\"Listed collections successfully\",\n        chromalogger.Int(\"count\", len(collections)),\n    )\n}\n</code></pre>"},{"location":"logging/#migration-from-debug-flag","title":"Migration from Debug Flag","text":"<p>\u26a0\ufe0f IMPORTANT: <code>WithDebug()</code> is deprecated. Migrate to <code>WithLogger()</code> for debug logging.</p> <p>Before (DEPRECATED): <pre><code>client, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithDebug(), // DEPRECATED - only prints a warning now\n)\n</code></pre></p> <p>After (RECOMMENDED): <pre><code>// Use WithLogger with a debug-level logger\nlogger, _ := chromalogger.NewDevelopmentZapLogger()\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre></p>"},{"location":"logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"logging/#no-logs-appearing","title":"No logs appearing","text":"<ol> <li>Check if your logger is properly configured and the log level allows the messages</li> <li>Ensure you're not using NoopLogger unintentionally</li> <li>For custom loggers, verify your implementation outputs to the expected destination</li> </ol>"},{"location":"logging/#too-many-logs","title":"Too many logs","text":"<ol> <li>Adjust the log level in your logger configuration</li> <li>Use NoopLogger for specific operations that don't need logging</li> <li>Consider using a logger with filtering capabilities</li> </ol>"},{"location":"logging/#performance-impact","title":"Performance impact","text":"<ol> <li>Use NoopLogger in production if logging is not needed</li> <li>Avoid expensive operations in log message formatting</li> <li>Use structured fields instead of string concatenation</li> </ol>"},{"location":"records/","title":"Records","text":"<p>Records are a mechanism that allows you to manage Chroma documents as a cohesive unit. This has several advantages over the traditional approach of managing documents, ids, embeddings, and metadata separately.</p> <p>Two concepts are important to keep in mind here:</p> <ul> <li>Record - corresponds to a single document in Chroma which includes id, embedding, metadata, the document or URI</li> <li>RecordSet - a single unit of work to insert, upsert, update or delete records.</li> </ul>"},{"location":"records/#record","title":"Record","text":"<p>A Record contains the following fields:</p> <ul> <li>ID (string)</li> <li>Document (string) - optional</li> <li>Metadata (map[string]interface{}) - optional</li> <li>Embedding ([]float32 or []int32, wrapped in Embedding struct)</li> <li>URI (string) - optional</li> </ul> <p>Here's the <code>Record</code> type:</p> <pre><code>package types\n\ntype Record struct {\n    ID        string\n    Embedding Embedding\n    Metadata  map[string]interface{}\n    Document  string\n    URI       string\n    err       error // indicating whether the record is valid\n}\n</code></pre>"},{"location":"records/#recordset","title":"RecordSet","text":"<p>A record set is a cohesive unit of work, allowing the user to add, upsert, update, or delete records.</p> <p>Operation support</p> <p>Currently the record set only supports add operation</p> <pre><code>rs, rerr := types.NewRecordSet(\n            types.WithEmbeddingFunction(types.NewConsistentHashEmbeddingFunction()),\n            types.WithIDGenerator(types.NewULIDGenerator()),\n        )\nif err != nil {\n    log.Fatalf(\"Error creating record set: %s\", err)\n}\n// you can loop here to add multiple records\nrs.WithRecord(types.WithDocument(\"Document 1 content\"), types.WithMetadata(\"key1\", \"value1\"))\nrs.WithRecord(types.WithDocument(\"Document 2 content\"), types.WithMetadata(\"key2\", \"value2\"))\nrecords, err = rs.BuildAndValidate(context.Background())\n</code></pre>"},{"location":"rerankers/","title":"Reranking Functions","text":"<p>V2 API Support</p> <p>The reranking functions work with both V1 and V2 APIs. The <code>Rerank</code> method accepts plain text and works universally. The <code>RerankResults</code> method interface shown below references V1 types (<code>chromago.QueryResults</code>). For V1-specific usage, pin your dependency to <code>v0.2.5</code> or earlier: <pre><code>go get github.com/amikos-tech/chroma-go@v0.2.5\n</code></pre></p> <p>Reranking functions allow users to feed Chroma results into a reranking model such as <code>cross-encoder/ms-marco-MiniLM-L-6-v2</code> to improve the quality of the search results.</p> <p>Rerankers take the returned documents from Chroma and the original query and rank each result's relevance to the query.</p>"},{"location":"rerankers/#how-to-use-rerankers","title":"How To Use Rerankers","text":"<p>Each reranker exposes the following methods:</p> <ul> <li><code>Rerank</code> which takes plain text query and results and returns a list of ranked results.</li> <li><code>RerankResults</code> which takes a <code>QueryResults</code> object and returns a list of <code>RerankedChromaResults</code> objects. RerankedChromaResults inherits from <code>QueryResults</code> and adds a <code>Ranks</code> field which contains the ranks of each result.</li> </ul> <pre><code>package rerankings\n\nimport (\n    \"context\"\n\n    chromago \"github.com/amikos-tech/chroma-go\"\n)\n\ntype RankedResult struct {\n    ID     int // Index in the original input []string\n    String string\n    Rank   float32\n}\n\ntype RerankedChromaResults struct {\n    chromago.QueryResults\n    Ranks [][]float32\n}\n\ntype RerankingFunction interface {\n    Rerank(ctx context.Context, query string, results []string) ([]*RankedResult, error)\n    RerankResults(ctx context.Context, queryResults *chromago.QueryResults) (RerankedChromaResults, error)\n}\n</code></pre>"},{"location":"rerankers/#supported-rerankers","title":"Supported Rerankers","text":"<ul> <li>Cohere - \u2705</li> <li>Jina AI - \u2705</li> <li>HuggingFace Text Embedding Inference - \u2705</li> <li>Together AI - \u2705</li> <li>HuggingFace Inference API - coming soon</li> </ul>"},{"location":"rerankers/#cohere-reranker","title":"Cohere Reranker","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    cohere \"github.com/amikos-tech/chroma-go/pkg/rerankings/cohere\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := cohere.NewCohereRerankingFunction(cohere.WithAPIKey(os.Getenv(\"COHERE_API_KEY\")))\n    if err != nil {\n        fmt.Printf(\"Error creating Cohere reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"rerankers/#jina-ai-reranker","title":"Jina AI Reranker","text":"<p>To use Jina AI reranking, you will need to get an API Key (trial API keys are freely available without any registration, scroll down the page and find the automatically generated API key).</p> <p>Supported models - https://api.jina.ai/redoc#tag/rerank/operation/rank_v1_rerank_post</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    jina \"github.com/amikos-tech/chroma-go/pkg/rerankings/jina\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := jina.NewJinaRerankingFunction(jina.WithAPIKey(os.Getenv(\"JINA_API_KEY\")))\n    if err != nil {\n        fmt.Printf(\"Error creating Jina reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"rerankers/#hfei-reranker","title":"HFEI Reranker","text":"<p>You need to run a local HFEI server. You can do that by running the following command:</p> <pre><code>docker run --rm -p 8080:80 -v $PWD/data:/data --platform linux/amd64 ghcr.io/huggingface/text-embeddings-inference:cpu-latest --model-id BAAI/bge-reranker-base\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    hf \"github.com/amikos-tech/chroma-go/pkg/rerankings/hf\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := hf.NewHFRerankingFunction(hf.WithRerankingEndpoint(\"http://127.0.0.1:8080/rerank\"))\n    if err != nil {\n        fmt.Printf(\"Error creating HFEI reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"rerankers/#together-ai-reranker","title":"Together AI Reranker","text":"<p>To use Together AI reranking, you will need to get an API Key.</p> <p>The default model is <code>Salesforce/Llama-Rank-V1</code>.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    together \"github.com/amikos-tech/chroma-go/pkg/rerankings/together\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := together.NewTogetherRerankingFunction(together.WithAPIKey(os.Getenv(\"TOGETHER_API_KEY\")))\n    if err != nil {\n        fmt.Printf(\"Error creating Together reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"search/","title":"Search API","text":"<p>The Search API provides advanced semantic search capabilities with flexible ranking, filtering, and pagination options. This is the recommended API for Chroma Cloud and for applications requiring complex search patterns.</p> <p>Cloud Feature</p> <p>The Search API is available in Chroma Cloud. For self-hosted Chroma, use the Query API instead.</p>"},{"location":"search/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    client, err := chroma.NewHTTPClient(\n        chroma.WithCloudAPIKey(\"your-api-key\"),\n        chroma.WithDatabaseAndTenant(\"your-tenant\", \"your-database\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer client.Close()\n\n    // Embedding function is required for text queries\n    ef, _ := openai.NewOpenAIEmbeddingFunction(\"sk-xxx\")\n\n    col, err := client.GetCollection(context.Background(), \"my-collection\",\n        chroma.WithEmbeddingFunctionGet(ef),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Simple text search\n    result, err := col.Search(context.Background(),\n        chroma.NewSearchRequest(\n            chroma.WithKnnRank(chroma.KnnQueryText(\"machine learning\")),\n            chroma.WithLimit(10),\n        ),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Found %d results\\n\", len(result.(*chroma.SearchResultImpl).IDs[0]))\n}\n</code></pre>"},{"location":"search/#search-components","title":"Search Components","text":"<p>A search request consists of four optional components:</p> Component Description Function Rank How to score and order results <code>WithKnnRank</code>, <code>WithRrfRank</code> Filter Which documents to include <code>WithFilter</code>, <code>WithIDs</code> Page Pagination (limit/offset) <code>NewPage</code>, <code>WithLimit</code>, <code>WithOffset</code> Select Which fields to return <code>WithSelect</code>, <code>WithSelectAll</code>"},{"location":"search/#ranking","title":"Ranking","text":""},{"location":"search/#knn-k-nearest-neighbors","title":"KNN (K-Nearest Neighbors)","text":"<p>KNN search finds documents with embeddings most similar to your query.</p> <pre><code>// Text query (auto-embedded using collection's embedding function)\nchroma.WithKnnRank(chroma.KnnQueryText(\"search query\"))\n\n// Dense vector query\nvector := embeddings.NewEmbeddingFromFloat32([]float32{0.1, 0.2, 0.3, ...})\nchroma.WithKnnRank(chroma.KnnQueryVector(vector))\n\n// Sparse vector query\nsparse, err := embeddings.NewSparseVector([]int{1, 5, 10}, []float32{0.5, 0.3, 0.8})\nif err != nil { return err }\nchroma.WithKnnRank(\n    chroma.KnnQuerySparseVector(sparse),\n    chroma.WithKnnKey(chroma.K(\"sparse_embedding\")),\n)\n</code></pre>"},{"location":"search/#knn-options","title":"KNN Options","text":"Option Description Default <code>WithKnnLimit(n)</code> Number of nearest neighbors to retrieve 16 <code>WithKnnKey(key)</code> Which embedding field to search <code>#embedding</code> <code>WithKnnDefault(score)</code> Score for documents not in top-K excluded <code>WithKnnReturnRank()</code> Return rank position instead of distance false <pre><code>knn, err := chroma.NewKnnRank(\n    chroma.KnnQueryText(\"AI research\"),\n    chroma.WithKnnLimit(100),\n    chroma.WithKnnDefault(10.0),\n    chroma.WithKnnKey(chroma.K(\"dense_embedding\")),\n)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"search/#weighted-combinations","title":"Weighted Combinations","text":"<p>Combine multiple searches with different weights:</p> <pre><code>// Dense + Sparse hybrid search (70% dense, 30% sparse)\ndense, _ := chroma.NewKnnRank(chroma.KnnQueryText(\"machine learning\"))\nsparse, _ := chroma.NewKnnRank(\n    chroma.KnnQuerySparseVector(sparseVector),\n    chroma.WithKnnKey(chroma.K(\"sparse_embedding\")),\n)\n\ncombined := dense.Multiply(chroma.FloatOperand(0.7)).Add(\n    sparse.Multiply(chroma.FloatOperand(0.3)),\n)\n\nresult, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithRank(combined),\n        chroma.WithLimit(10),\n    ),\n)\n</code></pre>"},{"location":"search/#mathematical-functions","title":"Mathematical Functions","text":"<p>Transform scores using mathematical operations:</p> Method Description Example <code>Add(op)</code> Addition <code>rank.Add(chroma.FloatOperand(1))</code> <code>Sub(op)</code> Subtraction <code>rank.Sub(otherRank)</code> <code>Multiply(op)</code> Multiplication <code>rank.Multiply(chroma.FloatOperand(0.5))</code> <code>Div(op)</code> Division <code>rank.Div(chroma.FloatOperand(10))</code> <code>Negate()</code> Negation <code>rank.Negate()</code> <code>Abs()</code> Absolute value <code>rank.Abs()</code> <code>Exp()</code> Exponential (e^x) <code>rank.Exp()</code> <code>Log()</code> Natural log <code>rank.Log()</code> <code>Max(op)</code> Maximum <code>rank.Max(chroma.FloatOperand(1.0))</code> <code>Min(op)</code> Minimum <code>rank.Min(chroma.FloatOperand(0.0))</code> <pre><code>// Exponential amplification\namplified, _ := chroma.NewKnnRank(chroma.KnnQueryText(\"query\"))\namplified = amplified.Exp()\n\n// Log compression (add 1 to avoid log(0))\ncompressed, _ := chroma.NewKnnRank(chroma.KnnQueryText(\"query\"))\ncompressed = compressed.Add(chroma.FloatOperand(1)).Log()\n\n// Score clamping to [0, 1]\nclamped, _ := chroma.NewKnnRank(chroma.KnnQueryText(\"query\"))\nclamped = clamped.Min(chroma.FloatOperand(0.0)).Max(chroma.FloatOperand(1.0))\n</code></pre>"},{"location":"search/#reciprocal-rank-fusion-rrf","title":"Reciprocal Rank Fusion (RRF)","text":"<p>RRF combines multiple ranking strategies using: <code>-sum(weight_i / (k + rank_i))</code></p> <pre><code>knn1, _ := chroma.NewKnnRank(\n    chroma.KnnQueryText(\"machine learning\"),\n    chroma.WithKnnReturnRank(), // Required for RRF\n)\nknn2, _ := chroma.NewKnnRank(\n    chroma.KnnQueryText(\"deep learning\"),\n    chroma.WithKnnReturnRank(),\n)\n\nrrf, err := chroma.NewRrfRank(\n    chroma.WithRrfRanks(\n        knn1.WithWeight(0.6),\n        knn2.WithWeight(0.4),\n    ),\n    chroma.WithRrfK(60),         // Smoothing constant (default: 60)\n    chroma.WithRrfNormalize(),   // Normalize weights to sum to 1.0\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nresult, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithRank(rrf),\n        chroma.WithLimit(10),\n    ),\n)\n</code></pre>"},{"location":"search/#filtering","title":"Filtering","text":""},{"location":"search/#metadata-filters","title":"Metadata Filters","text":"<p>Filter documents by metadata attributes:</p> <pre><code>// Single condition\nchroma.WithFilter(chroma.EqString(\"status\", \"published\"))\n\n// Combined conditions\nchroma.WithFilter(\n    chroma.And(\n        chroma.EqString(\"status\", \"published\"),\n        chroma.GtInt(\"views\", 100),\n    ),\n)\n</code></pre>"},{"location":"search/#filter-operators","title":"Filter Operators","text":"Operator Description Example <code>EqString</code> String equals <code>EqString(\"type\", \"article\")</code> <code>EqInt</code> Integer equals <code>EqInt(\"count\", 5)</code> <code>EqFloat</code> Float equals <code>EqFloat(\"score\", 0.95)</code> <code>EqBool</code> Boolean equals <code>EqBool(\"active\", true)</code> <code>NeString</code> Not equals <code>NeString(\"status\", \"draft\")</code> <code>GtInt</code> Greater than <code>GtInt(\"views\", 100)</code> <code>GteInt</code> Greater than or equal <code>GteInt(\"priority\", 1)</code> <code>LtInt</code> Less than <code>LtInt(\"age\", 30)</code> <code>LteInt</code> Less than or equal <code>LteInt(\"rank\", 10)</code> <code>InStrings</code> In list <code>InStrings(\"category\", []string{\"tech\", \"science\"})</code> <code>NinStrings</code> Not in list <code>NinStrings(\"tag\", []string{\"spam\", \"test\"})</code> <code>And</code> Logical AND <code>And(filter1, filter2)</code> <code>Or</code> Logical OR <code>Or(filter1, filter2)</code>"},{"location":"search/#document-id-filter","title":"Document ID Filter","text":"<p>Restrict search to specific document IDs using <code>WithIDs</code>:</p> <pre><code>chroma.WithIDs(\"doc1\", \"doc2\", \"doc3\")\n</code></pre> <p>For more flexible ID filtering that can be combined with other where clauses, use <code>IDIn</code> and <code>IDNotIn</code>:</p> <p>Note: <code>IDIn</code> and <code>IDNotIn</code> are Cloud-only features. These functions follow the Python SDK pattern (<code>K.ID.is_in()</code>, <code>K.ID.not_in()</code>).</p> <pre><code>// Include only specific IDs (equivalent to Python's K.ID.is_in())\nchroma.WithFilter(chroma.IDIn(\"doc1\", \"doc2\", \"doc3\"))\n\n// Exclude specific IDs (equivalent to Python's K.ID.not_in())\nchroma.WithFilter(chroma.IDNotIn(\"seen1\", \"seen2\", \"seen3\"))\n\n// Combine with other filters - useful for excluding already-seen content\nchroma.WithFilter(chroma.And(\n    chroma.EqString(\"category\", \"tech\"),\n    chroma.IDNotIn(\"already_read_1\", \"already_read_2\"),\n))\n</code></pre>"},{"location":"search/#combining-filters","title":"Combining Filters","text":"<pre><code>result, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"AI research\")),\n        chroma.WithFilter(\n            chroma.And(\n                chroma.EqString(\"status\", \"published\"),\n                chroma.InStrings(\"category\", []string{\"tech\", \"science\"}),\n            ),\n        ),\n        chroma.WithIDs(\"doc1\", \"doc2\", \"doc3\"),\n        chroma.NewPage(chroma.Limit(20)),\n    ),\n)\n</code></pre>"},{"location":"search/#pagination","title":"Pagination","text":"<p>Control result pagination with limit and offset. The recommended approach is using the <code>Page</code> type for fluent navigation.</p>"},{"location":"search/#using-page-recommended","title":"Using Page (Recommended)","text":"<pre><code>// Create a page with custom size - inline usage\nresult, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"query\")),\n        chroma.NewPage(chroma.Limit(20)),\n    ),\n)\n\n// Or reuse for navigation\npage := chroma.NewPage(chroma.Limit(20))\npage = page.Next()  // Offset becomes 20\npage = page.Prev()  // Back to offset 0\n</code></pre>"},{"location":"search/#iteration-pattern","title":"Iteration Pattern","text":"<p><code>Page</code> eliminates off-by-one errors in pagination loops:</p> <pre><code>page := chroma.NewPage(chroma.Limit(20))\nfor {\n    result, err := col.Search(ctx,\n        chroma.NewSearchRequest(\n            chroma.WithKnnRank(chroma.KnnQueryText(\"query\")),\n            page,\n        ),\n    )\n    if err != nil {\n        break\n    }\n\n    rows := result.(*chroma.SearchResultImpl).Rows()\n    if len(rows) == 0 {\n        break  // No more results\n    }\n\n    // Process rows...\n\n    page = page.Next()  // Move to next page\n}\n</code></pre>"},{"location":"search/#page-methods","title":"Page Methods","text":"Method Description <code>NewPage(opts...)</code> Create a page (default limit: 10) <code>Limit(n)</code> Set page size (must be &gt; 0) <code>Offset(n)</code> Set starting offset (must be &gt;= 0) <code>Next()</code> Return new page for next results <code>Prev()</code> Return new page for previous results (clamped to 0) <code>Number()</code> Current page number (0-indexed) <code>Size()</code> Page size (limit) <code>GetOffset()</code> Current offset"},{"location":"search/#using-withlimit-and-withoffset","title":"Using WithLimit and WithOffset","text":"<p>For simple cases, you can use <code>WithLimit</code> and <code>WithOffset</code> directly:</p> <pre><code>// First page (10 results)\nchroma.WithLimit(10)\n\n// Third page (skip 20 results)\nchroma.WithLimit(10)\nchroma.WithOffset(20)\n</code></pre>"},{"location":"search/#projection-select","title":"Projection (Select)","text":"<p>Choose which fields to include in results:</p> <pre><code>// Select specific fields\nchroma.WithSelect(chroma.KDocument, chroma.KScore, chroma.K(\"title\"))\n\n// Select all standard fields\nchroma.WithSelectAll()\n</code></pre>"},{"location":"search/#projection-keys","title":"Projection Keys","text":"Key Description <code>KID</code> Document ID <code>KDocument</code> Document text <code>KEmbedding</code> Vector embedding <code>KMetadata</code> All metadata fields <code>KScore</code> Ranking score <code>K(\"field\")</code> Custom metadata field"},{"location":"search/#complete-examples","title":"Complete Examples","text":""},{"location":"search/#semantic-search-with-filters","title":"Semantic Search with Filters","text":"<pre><code>result, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(\n            chroma.KnnQueryText(\"latest AI research\"),\n            chroma.WithKnnLimit(100),\n        ),\n        chroma.WithFilter(\n            chroma.And(\n                chroma.EqString(\"status\", \"published\"),\n                chroma.GtInt(\"year\", 2023),\n            ),\n        ),\n        chroma.WithLimit(10),\n        chroma.WithSelect(chroma.KDocument, chroma.KScore, chroma.K(\"title\")),\n    ),\n)\n</code></pre>"},{"location":"search/#hybrid-dense-sparse-search","title":"Hybrid Dense + Sparse Search","text":"<pre><code>dense, _ := chroma.NewKnnRank(\n    chroma.KnnQueryText(\"neural networks\"),\n    chroma.WithKnnLimit(100),\n    chroma.WithKnnDefault(1000.0),\n)\n\nsparse, _ := chroma.NewKnnRank(\n    chroma.KnnQuerySparseVector(sparseVector),\n    chroma.WithKnnKey(chroma.K(\"sparse_embedding\")),\n    chroma.WithKnnLimit(100),\n    chroma.WithKnnDefault(1000.0),\n)\n\n// 70% dense, 30% sparse\nhybrid := dense.Multiply(chroma.FloatOperand(0.7)).Add(\n    sparse.Multiply(chroma.FloatOperand(0.3)),\n)\n\nresult, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithRank(hybrid),\n        chroma.WithLimit(10),\n    ),\n)\n</code></pre>"},{"location":"search/#multi-query-with-rrf","title":"Multi-Query with RRF","text":"<pre><code>semantic, _ := chroma.NewKnnRank(\n    chroma.KnnQueryText(\"machine learning algorithms\"),\n    chroma.WithKnnReturnRank(),\n    chroma.WithKnnLimit(50),\n)\n\nkeyword, _ := chroma.NewKnnRank(\n    chroma.KnnQuerySparseVector(bm25Vector),\n    chroma.WithKnnKey(chroma.K(\"bm25_embedding\")),\n    chroma.WithKnnReturnRank(),\n    chroma.WithKnnLimit(50),\n)\n\nrrf, _ := chroma.NewRrfRank(\n    chroma.WithRrfRanks(\n        semantic.WithWeight(0.6),\n        keyword.WithWeight(0.4),\n    ),\n    chroma.WithRrfK(60),\n)\n\nresult, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithRank(rrf),\n        chroma.WithFilter(chroma.EqString(\"type\", \"paper\")),\n        chroma.WithLimit(10),\n        chroma.WithSelect(chroma.KDocument, chroma.KScore, chroma.K(\"title\"), chroma.K(\"authors\")),\n    ),\n)\n</code></pre>"},{"location":"search/#no-ranking-index-order","title":"No Ranking (Index Order)","text":"<p>Retrieve documents without ranking (useful for filtered retrieval):</p> <pre><code>result, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithFilter(chroma.EqString(\"status\", \"active\")),\n        chroma.NewPage(chroma.Limit(100)),\n    ),\n)\n</code></pre>"},{"location":"search/#read-level","title":"Read Level","text":"<p>Control whether searches read from the write-ahead log (WAL) or only the compacted index:</p> Level Description <code>ReadLevelIndexAndWAL</code> Read from both index and WAL (default). All committed writes visible. <code>ReadLevelIndexOnly</code> Read only from compacted index. Faster, but recent writes may not be visible. <pre><code>// Default behavior - reads from both index and WAL\nresult, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"query\")),\n    ),\n    chroma.WithReadLevel(chroma.ReadLevelIndexAndWAL),\n)\n\n// Faster search - only reads from compacted index\nresult, err := col.Search(ctx,\n    chroma.NewSearchRequest(\n        chroma.WithKnnRank(chroma.KnnQueryText(\"query\")),\n    ),\n    chroma.WithReadLevel(chroma.ReadLevelIndexOnly),\n)\n</code></pre> <p>Index-Only Reads</p> <p><code>ReadLevelIndexOnly</code> provides faster searches but documents added recently that haven't been compacted into the index may not appear in results.</p>"},{"location":"search/#error-handling","title":"Error Handling","text":"<p>Both <code>NewKnnRank</code> and <code>NewRrfRank</code> return errors that should be checked:</p> <pre><code>knn, err := chroma.NewKnnRank(\n    chroma.KnnQueryText(\"query\"),\n    chroma.WithKnnLimit(100),\n)\nif err != nil {\n    log.Fatalf(\"Failed to create KNN rank: %v\", err)\n}\n\nrrf, err := chroma.NewRrfRank(\n    chroma.WithRrfRanks(knn.WithWeight(1.0)),\n)\nif err != nil {\n    log.Fatalf(\"Failed to create RRF rank: %v\", err)\n}\n</code></pre>"},{"location":"search/#api-reference","title":"API Reference","text":""},{"location":"search/#search-options","title":"Search Options","text":"Function Description <code>NewSearchRequest(opts...)</code> Create a search request with options <code>WithKnnRank(query, opts...)</code> Add KNN ranking to request <code>WithRrfRank(opts...)</code> Add RRF ranking to request <code>WithFilter(where)</code> Add metadata filter <code>WithIDs(ids...)</code> Filter by document IDs (unified option) <code>NewPage(opts...)</code> Create a fluent pagination object (recommended) <code>Limit(n)</code> Set page size (for NewPage) <code>Offset(n)</code> Set offset (for NewPage) <code>WithLimit(n)</code> Set result limit directly <code>WithOffset(n)</code> Set result offset directly <code>WithSelect(keys...)</code> Select fields to return <code>WithSelectAll()</code> Select all standard fields <code>WithReadLevel(level)</code> Set read level (<code>ReadLevelIndexAndWAL</code> or <code>ReadLevelIndexOnly</code>)"},{"location":"search/#knn-options_1","title":"KNN Options","text":"Function Description <code>KnnQueryText(text)</code> Query with text (auto-embedded) <code>KnnQueryVector(vec)</code> Query with dense vector <code>KnnQuerySparseVector(vec)</code> Query with sparse vector <code>WithKnnLimit(n)</code> Set K neighbors to retrieve <code>WithKnnKey(key)</code> Set embedding field to search <code>WithKnnDefault(score)</code> Set default score for non-matches <code>WithKnnReturnRank()</code> Return rank instead of distance"},{"location":"search/#rrf-options","title":"RRF Options","text":"Function Description <code>WithRrfRanks(ranks...)</code> Add weighted ranks <code>WithRrfK(k)</code> Set smoothing constant <code>WithRrfNormalize()</code> Normalize weights"},{"location":"search/#id-filter-operators-cloud-only","title":"ID Filter Operators (Cloud-only)","text":"Function Description <code>IDIn(ids...)</code> Match documents with any of the specified IDs <code>IDNotIn(ids...)</code> Exclude documents with any of the specified IDs"}]}