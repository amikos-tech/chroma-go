{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chroma Go Client","text":"<p>An experimental Go client for ChromaDB.</p>"},{"location":"#installation","title":"Installation","text":"<p>Add the library to your project:</p> <pre><code>go get github.com/amikos-tech/chroma-go\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Concepts:</p> <ul> <li>Client Options - How to configure chroma go client</li> <li>Embeddings - List of available embedding functions and how to use them</li> <li>Records - How to work with records</li> <li>Filtering - How to filter results</li> </ul> <p>Import the library:</p> <pre><code>package main\n\nimport (\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/collection\"\n    openai \"github.com/amikos-tech/chroma-go/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n</code></pre> <p>New client:</p> <p>Note</p> <p>Check Client Options for more details.</p> <pre><code>package main\n\nimport (\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"fmt\"\n)\n\nfunc main() {\n    client,err := chroma.NewClient(chroma.WithBasePath(\"http://localhost:8000\"))\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n    // do something with client\n}\n</code></pre>"},{"location":"#embedding-functions","title":"Embedding Functions","text":"<p>The client supports a number of embedding wrapper functions. See Embeddings for more details.</p>"},{"location":"#crud-operations","title":"CRUD Operations","text":"<p>Ensure you have a running instance of Chroma running. See this doc for more info how to run local Chroma instance.</p> <p>Here's a simple example of creating a new collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client := chroma.NewClient() //connects to localhost:8000\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n\n    // Create a new collection with OpenAI embedding function, L2 distance function and metadata\n    _, err = client.CreateCollection(ctx, \"my-collection\", map[string]interface{}{\"key1\": \"value1\"}, true, openaiEf, types.L2)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n    }\n\n    // Get collection\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to get collection: %v\", err)\n    }\n\n    // Modify collection\n    _, err = collection.Update(ctx, \"new-collection\",nil)\n    if err != nil {\n        log.Fatalf(\"Failed to update collection: %v\", err)\n    }\n\n    // Delete collection\n    _, err = client.DeleteCollection(ctx, \"new-collection\")\n    if err != nil {\n        log.Fatalf(\"Failed to delete collection: %v\", err)\n    }\n}\n</code></pre>"},{"location":"#add-documents","title":"Add documents","text":"<p>Here's a simple example of adding documents to a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client := chroma.NewClient() //connects to localhost:8000\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    _, err = collection.Add(context.TODO(), nil, []map[string]interface{}{{\"key1\": \"value1\"}}, []string{\"My name is John and I have three dogs.\"}, []string{\"ID1\"})\n    if err != nil {\n        log.Fatalf(\"Error adding documents: %v\\n\", err)\n        return\n    }\n    data, err := collection.Get(context.TODO(), nil, nil, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error getting documents: %v\\n\", err)\n        return\n    }\n    // see GetResults struct for more details\n    fmt.Printf(\"Collection data: %v\\n\", data)\n}\n</code></pre>"},{"location":"#query-collection","title":"Query Collection","text":"<p>Here's a simple example of querying documents in a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client := chroma.NewClient() //connects to localhost:8000\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    data, err := collection.Query(context.TODO(), []string{\"I love dogs\"}, 5, nil, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error querying documents: %v\\n\", err)\n        return\n    }\n    // see QueryResults struct for more details\n    fmt.Printf(\"Collection data: %v\\n\", data)\n}\n</code></pre>"},{"location":"#delete-documents","title":"Delete Documents","text":"<p>Here's a simple example of deleting documents from a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client := chroma.NewClient() //connects to localhost:8000\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    _, err = collection.Delete(context.TODO(), []string{\"ID1\"}, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error deleting documents: %v\\n\", err)\n        return\n    }\n    fmt.Printf(\"Documents deleted\\n\")\n}\n</code></pre>"},{"location":"auth/","title":"Authentication","text":"<p>There are four ways to authenticate with Chroma:</p> <ul> <li>Manual Header authentication - this approach requires you to be familiar with the server-side auth and generate and insert the necessary headers manually.</li> <li>Chroma Basic Auth mechanism</li> <li>Chroma Token Auth mechanism with Bearer Authorization header</li> <li>Chroma Token Auth mechanism with X-Chroma-Token header</li> </ul>"},{"location":"auth/#manual-header-authentication","title":"Manual Header Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    var defaultHeaders = map[string]string{\"Authorization\": \"Bearer my-custom-token\"}\n    clientWithTenant, err := chroma.NewClient(chroma.WithBasePath(\"http://api.trychroma.com/v1/\"), chroma.WithDefaultHeaders(defaultHeaders))\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = clientWithTenant.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-basic-auth-mechanism","title":"Chroma Basic Auth mechanism","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://api.trychroma.com/v1/\"),\n        chroma.WithAuth(types.NewBasicAuthCredentialsProvider(\"myUser\", \"myPassword\")),\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = client.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-token-auth-mechanism-with-bearer-authorization-header","title":"Chroma Token Auth mechanism with Bearer Authorization header","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://api.trychroma.com/v1/\"), \n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-auth-token\", types.AuthorizationTokenHeader)),\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = client.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-token-auth-mechanism-with-x-chroma-token-header","title":"Chroma Token Auth mechanism with X-Chroma-Token header","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://api.trychroma.com/v1/\"), \n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-auth-token\", types.XChromaTokenHeader)),\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    _, err = client.Heartbeat(context.TODO())\n    if err != nil {\n        log.Fatalf(\"Error calling heartbeat: %s \\n\", err)\n    }\n}\n</code></pre>"},{"location":"client/","title":"Chroma Client","text":"<p>Options:</p> Options Usage Description Value Required basePath <code>WithBasePath(\"http://localhost:8000\")</code> The Chroma server base API. Non-empty valid URL string No (default: <code>http://localhost:8000</code>) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> No (default: <code>default_tenant</code>) Database <code>WithDatabase(\"database\")</code> The default database to use. <code>string</code> No (default: <code>default_database</code>) Debug <code>WithDebug(true/false)</code> Enable debug mode. <code>bool</code> No (default: <code>false</code>) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default headers for the client. <code>map[string]string</code> No (default: <code>nil</code>) SSL Cert <code>WithSSLCert(\"path/to/cert.pem\")</code> Set the path to the SSL certificate. valid path to SSL cert. No (default: Not Set) Insecure <code>WithInsecure()</code> Disable SSL certificate verification No (default: Not Set) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) <p>Tenant and Database</p> <p>The tenant and database are only supported for Chroma API version <code>0.4.15+</code>.</p> <p>Creating a new client:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithTenant(\"my_tenant\"),\n        chroma.WithDatabase(\"my_db\"),\n        chroma.WithDebug(true),\n        chroma.WithDefaultHeaders(map[string]string{\"Authorization\": \"Bearer my token\"}),\n        chroma.WithSSLCert(\"path/to/cert.pem\"),\n    )\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n    // do something with client\n}\n</code></pre>"},{"location":"embeddings/","title":"Embedding Models","text":"<p>The following embedding wrappers are available:</p> Embedding Model Description Default Embeddings The default Chroma embedding function running <code>all-MiniLM-L6-v2</code> on Onnx Runtime OpenAI OpenAI embeddings API.All models are supported - see OpenAI docs for more info. Cohere Cohere embeddings API.All models are supported - see Cohere API docs for more info. HuggingFace Inference API HuggingFace Inference API.All models supported by the API. HuggingFace Embedding Inference Server HuggingFace Embedding Inference Server.Models supported by the inference server. Ollama Ollama embeddings API.All models are supported - see Ollama models lib for more info. Cloudflare Workers AI Cloudflare Workers AI Embedding. For more info see CF API Docs. Together AI Together AI Embedding. For more info see Together API Docs. Voyage AI Voyage AI Embedding. For more info see Together API Docs. Google Gemini Google Gemini Embedding. For more info see Gemini Docs. Mistral AI Mistral AI Embedding. For more info see Mistral AI API Docs. Nomic AI Nomic AI Embedding. For more info see Nomic AI API Docs."},{"location":"embeddings/#default-embeddings","title":"Default Embeddings","text":"<p>Note: Supported from 0.2.0+</p> <p>The default embedding function uses the <code>all-MiniLM-L6-v2</code> model running on Onnx Runtime.</p> <p>Note: As the EF relies on C bindings to avoid memory leaks make sure to call the close callback</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    defaultef \"github.com/amikos-tech/chroma-go/pkg/embeddings/default_ef\"\n)\n\nfunc main() {\n    ef, closeef, efErr := defaultef.NewDefaultEmbeddingFunction()\n    defer closeef() // make sure to call this to ensure proper resource release\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#openai","title":"OpenAI","text":"<p>Supported Embedding Function Options:</p> <ul> <li><code>WithModel</code> - Set the OpenAI model to use. Default is <code>TextEmbeddingAda002</code> (<code>text-embedding-ada-002</code>).</li> <li><code>WithBaseURL</code> - Set the OpenAI base URL. Default is <code>https://api.openai.com/v1</code>. This allows you to point the EF to a   compatible OpenAI API endpoint.</li> <li><code>WithDimensions</code> - Set the number of dimensions for the embeddings. Default is <code>None</code> which returns the full   embeddings.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    openai \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ef, efErr := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"), openai.WithModel(openai.TextEmbedding3Large))\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cohere","title":"Cohere","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    cohere \"github.com/amikos-tech/chroma-go/pkg/embeddings/cohere\"\n)\n\nfunc main() {\n    ef := cohere.NewCohereEmbeddingFunction(os.Getenv(\"COHERE_API_KEY\"))\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-inference-api","title":"HuggingFace Inference API","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/pkg/embeddings/hf\"\n)\n\nfunc main() {\n    ef := huggingface.NewHuggingFaceEmbeddingFunction(os.Getenv(\"HUGGINGFACE_API_KEY\"), \"sentence-transformers/all-MiniLM-L6-v2\")\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-embedding-inference-server","title":"HuggingFace Embedding Inference Server","text":"<p>The embedding server allows you to run supported model locally on your machine with CPU and GPU inference. For more information check the HuggingFace Embedding Inference Server repository.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/hf\"\n)\n\nfunc main() {\n    ef, err := huggingface.NewHuggingFaceEmbeddingInferenceFunction(\"http://localhost:8001/embed\") //set this to the URL of the HuggingFace Embedding Inference Server\n    if err != nil {\n        fmt.Printf(\"Error creating HuggingFace embedding function: %s \\n\", err)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#ollama","title":"Ollama","text":"<p>Assumptions</p> <p>The below example assumes that you have an Ollama server running locally on <code>http://127.0.0.1:11434</code>.</p> <p>Use the following command to start the Ollama server:</p> <pre><code>    docker run -d -v ./ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama\n    docker exec -it ollama ollama run nomic-embed-text # press Ctrl+D to exit after model downloads successfully\n    # test it\n    curl http://localhost:11434/api/embeddings -d '{\"model\": \"nomic-embed-text\",\"prompt\": \"Here is an article about llamas...\"}'\n ```\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    ollama \"github.com/amikos-tech/chroma-go/pkg/embeddings/ollama\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // the `/api/embeddings` endpoint is automatically appended to the base URL\n    ef, err := ollama.NewOllamaEmbeddingFunction(ollama.WithBaseURL(\"http://127.0.0.1:11434\"), ollama.WithModel(\"nomic-embed-text\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Ollama embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cloudflare-workers-ai","title":"Cloudflare Workers AI","text":"<p>You will need to register for a Cloudflare account and create a API Token for Workers AI - see docs for more info.</p> <p>Models can be found in the Cloudflare Workers AI docs. <code>@cf/baai/bge-base-en-v1.5</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    cf \"github.com/amikos-tech/chroma-go/pkg/embeddings/cloudflare\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `CF_API_TOKEN` and `CF_ACCOUNT_ID` set in your environment\n    ef, err := cf.NewCloudflareEmbeddingFunction(cf.WithEnvAPIToken(), cf.WithEnvAccountID(), cf.WithDefaultModel(\"@cf/baai/bge-small-en-v1.5\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Cloudflare embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#together-ai","title":"Together AI","text":"<p>To use Together AI embeddings, you will need to register for a Together AI account and create an API Key.</p> <p>Available models can be in Together AI docs. <code>togethercomputer/m2-bert-80M-8k-retrieval</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/together\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `TOGETHER_API_KEY` set in your environment\n    ef, err := t.NewTogetherEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"togethercomputer/m2-bert-80M-2k-retrieval\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#voyage-ai","title":"Voyage AI","text":"<p>To use Voyage AI embeddings, you will need to register for a Voyage AI account and create an API Key.</p> <p>Available models can be in Voyage AI docs. <code>voyage-2</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/voyage\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `VOYAGE_API_KEY` set in your environment\n    ef, err := t.NewVoyageAIEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"voyage-large-2\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#google-gemini","title":"Google Gemini","text":"<p>To use Google Gemini AI embeddings, you will need to create an API Key.</p> <p>Available models can be in Gemini Models. <code>text-embedding-004</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    g \"github.com/amikos-tech/chroma-go/pkg/embeddings/gemini\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `GEMINI_API_KEY` set in your environment\n    ef, err := g.NewGeminiEmbeddingFunction(g.WithEnvAPIKey(), g.WithDefaultModel(\"text-embedding-004\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Gemini embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#mistral-ai","title":"Mistral AI","text":"<p>To use Mistral AI embeddings, you will need to create an API Key.</p> <p>Currently, (as of July 2024) only <code>mistral-embed</code> model is available, which is the default model we use.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    mistral \"github.com/amikos-tech/chroma-go/pkg/embeddings/mistral\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `MISTRAL_API_KEY` set in your environment\n    ef, err := mistral.NewMistralEmbeddingFunction(mistral.WithEnvAPIKey(), mistral.WithDefaultModel(\"mistral-embed\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Mistral embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#nomic-ai","title":"Nomic AI","text":"<p>To use Nomic AI embeddings, you will need to create an API Key.</p> <p>Supported models - https://docs.nomic.ai/atlas/models/text-embedding</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    nomic \"github.com/amikos-tech/chroma-go/pkg/embeddings/nomic\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `NOMIC_API_KEY` set in your environment\n    ef, err := nomic.NewNomicEmbeddingFunction(nomic.WithEnvAPIKey(), nomic.WithDefaultModel(nomic.NomicEmbedTextV1))\n    if err != nil {\n        fmt.Printf(\"Error creating Nomic embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"filtering/","title":"Filtering","text":"<p>Chroma offers two types of filters:</p> <ul> <li>Metadata - filtering based on metadata attribute values</li> <li>Documents - filtering based on document content (contains or not contains)</li> </ul>"},{"location":"filtering/#metadata","title":"Metadata","text":"<ul> <li>TODO - Add builder example</li> <li>TODO - Describe all available operations</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    \"github.com/amikos-tech/chroma-go/where\"\n)\n\nfunc main() {\n    embeddingF, err := openai.NewOpenAIEmbeddingFunction(\"sk-xxxx\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    client, err := chroma.NewClient() // connects to localhost:8000\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    collection, err := client.GetCollection(context.TODO(), \"my-collection\", embeddingF)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // Filter by metadata\n\n    result, err := collection.GetWithOptions(\n        context.Background(),\n        types.WithWhere(\n            where.Or(\n                where.Eq(\"category\", \"Chroma\"),\n                where.Eq(\"type\", \"vector database\"),\n            ),\n        ),\n    )\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // do something with result\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"filtering/#document","title":"Document","text":"<ul> <li>TODO - Add builder example</li> <li>TODO - Describe all available operations</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    \"github.com/amikos-tech/chroma-go/where_document\"\n)\n\nfunc main() {\n    embeddingF, err := openai.NewOpenAIEmbeddingFunction(\"sk-xxxx\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    client, err := chroma.NewClient(chroma.WithBasePath(\"http://localhost:8000\"))\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    collection, err := client.GetCollection(context.TODO(), \"my-collection\", embeddingF)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // Filter by metadata\n\n    result, err := collection.GetWithOptions(\n        context.Background(),\n        types.WithWhereDocument(\n            wheredoc.Or(\n                wheredoc.Contains(\"Vector database\"),\n                wheredoc.Contains(\"Chroma\"),\n            ),\n        ),\n    )\n\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // do something with result\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"records/","title":"Records","text":"<p>Records are a mechanism that allows you to manage Chroma documents as a cohesive unit. This has several advantages over the traditional approach of managing documents, ids, embeddings, and metadata separately.</p> <p>Two concepts are important to keep in mind here:</p> <ul> <li>Record - corresponds to a single document in Chroma which includes id, embedding, metadata, the document or URI</li> <li>RecordSet - a single unit of work to insert, upsert, update or delete records.</li> </ul>"},{"location":"records/#record","title":"Record","text":"<p>A Record contains the following fields:</p> <ul> <li>ID (string)</li> <li>Document (string) - optional</li> <li>Metadata (map[string]interface{}) - optional</li> <li>Embedding ([]float32 or []int32, wrapped in Embedding struct)</li> <li>URI (string) - optional</li> </ul> <p>Here's the <code>Record</code> type:</p> <pre><code>package types\n\ntype Record struct {\n    ID        string\n    Embedding Embedding\n    Metadata  map[string]interface{}\n    Document  string\n    URI       string\n    err       error // indicating whether the record is valid\n}\n</code></pre>"},{"location":"records/#recordset","title":"RecordSet","text":"<p>A record set is a cohesive unit of work, allowing the user to add, upsert, update, or delete records.</p> <p>Operation support</p> <p>Currently the record set only supports add operation</p> <pre><code>rs, rerr := types.NewRecordSet(\n            types.WithEmbeddingFunction(types.NewConsistentHashEmbeddingFunction()),\n            types.WithIDGenerator(types.NewULIDGenerator()),\n        )\nif err != nil {\n    log.Fatalf(\"Error creating record set: %s\", err)\n}\n// you can loop here to add multiple records\nrs.WithRecord(types.WithDocument(\"Document 1 content\"), types.WithMetadata(\"key1\", \"value1\"))\nrs.WithRecord(types.WithDocument(\"Document 2 content\"), types.WithMetadata(\"key2\", \"value2\"))\nrecords, err = rs.BuildAndValidate(context.Background())\n</code></pre>"},{"location":"rerankers/","title":"Reranking Functions","text":"<p>Reranking functions allow users to feed Chroma results into a reranking model such as <code>cross-encoder/ms-marco-MiniLM-L-6-v2</code> to improve the quality of the search results.</p> <p>Rerankers take the returned documents from Chroma and the original query and rank each result's relevance to the query.</p>"},{"location":"rerankers/#how-to-use-rerankers","title":"How To Use Rerankers","text":"<p>Each reranker exposes the following methods:</p> <ul> <li><code>Rerank</code> which takes plain text query and results and returns a list of ranked results.</li> <li><code>RerankResults</code> which takes a <code>QueryResults</code> object and returns a list of <code>RerankedChromaResults</code> objects. RerankedChromaResults inherits from <code>QueryResults</code> and adds a <code>Ranks</code> field which contains the ranks of each result.</li> </ul> <pre><code>package rerankings\n\nimport (\n    \"context\"\n\n    chromago \"github.com/amikos-tech/chroma-go\"\n)\n\ntype RankedResult struct {\n    ID     int // Index in the original input []string\n    String string\n    Rank   float32\n}\n\ntype RerankedChromaResults struct {\n    chromago.QueryResults\n    Ranks [][]float32\n}\n\ntype RerankingFunction interface {\n    Rerank(ctx context.Context, query string, results []string) ([]*RankedResult, error)\n    RerankResults(ctx context.Context, queryResults *chromago.QueryResults) (RerankedChromaResults, error)\n}\n</code></pre>"},{"location":"rerankers/#supported-rerankers","title":"Supported Rerankers","text":"<ul> <li>Cohere - coming soon</li> <li>HuggingFace Text Embedding Inference - coming soon</li> <li>HuggingFace Inference API - coming soon</li> </ul>"}]}