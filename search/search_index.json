{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chroma Go Client","text":"<p>An experimental Go client for ChromaDB.</p>"},{"location":"#installation","title":"Installation","text":"<p>Add the library to your project:</p> <pre><code>go get github.com/amikos-tech/chroma-go\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Concepts:</p> <ul> <li>Client Options - How to configure chroma go client</li> <li>Embeddings - List of available embedding functions and how to use them</li> <li>Records - How to work with records</li> <li>Filtering - How to filter results</li> </ul> <p>Import the library:</p> <pre><code>package main\n\nimport (\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/collection\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n</code></pre> <p>New client:</p> <p>Note</p> <p>Check Client Options for more details.</p> <pre><code>package main\n\nimport (\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"fmt\"\n)\n\nfunc main() {\n    client,err := chroma.NewClient(chroma.WithBasePath(\"http://localhost:8000\"))\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n    // do something with client\n}\n</code></pre>"},{"location":"#embedding-functions","title":"Embedding Functions","text":"<p>The client supports a number of embedding wrapper functions. See Embeddings for more details.</p>"},{"location":"#crud-operations","title":"CRUD Operations","text":"<p>Ensure you have a running instance of Chroma running. See this doc for more info how to run local Chroma instance.</p> <p>Here's a simple example of creating a new collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    openai \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client,err := chroma.NewClient() //connects to localhost:8000\\\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n\n    // Create a new collection with OpenAI embedding function, L2 distance function and metadata\n    _, err = client.CreateCollection(ctx, \"my-collection\", map[string]interface{}{\"key1\": \"value1\"}, true, openaiEf, types.L2)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n    }\n\n    // Get collection\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to get collection: %v\", err)\n    }\n\n    // Modify collection\n    _, err = collection.Update(ctx, \"new-collection\",nil)\n    if err != nil {\n        log.Fatalf(\"Failed to update collection: %v\", err)\n    }\n\n    // Delete collection\n    _, err = client.DeleteCollection(ctx, \"new-collection\")\n    if err != nil {\n        log.Fatalf(\"Failed to delete collection: %v\", err)\n    }\n}\n</code></pre>"},{"location":"#add-documents","title":"Add documents","text":"<p>Here's a simple example of adding documents to a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client, err := chroma.NewClient() //connects to localhost:8000\n    if err !=nil{\n        log.Fatalf(\"Failed to create client: %v\", err)\n    }\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    _, err = collection.Add(context.TODO(), nil, []map[string]interface{}{{\"key1\": \"value1\"}}, []string{\"My name is John and I have three dogs.\"}, []string{\"ID1\"})\n    if err != nil {\n        log.Fatalf(\"Error adding documents: %v\\n\", err)\n        return\n    }\n    data, err := collection.Get(context.TODO(), nil, nil, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error getting documents: %v\\n\", err)\n        return\n    }\n    // see GetResults struct for more details\n    fmt.Printf(\"Collection data: %v\\n\", data)\n}\n</code></pre>"},{"location":"#query-collection","title":"Query Collection","text":"<p>Here's a simple example of querying documents in a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client,err := chroma.NewClient() //connects to localhost:8000\n\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    data, err := collection.Query(context.TODO(), []string{\"I love dogs\"}, 5, nil, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error querying documents: %v\\n\", err)\n        return\n    }\n    // see QueryResults struct for more details\n    fmt.Printf(\"Collection data: %v\\n\", data)\n}\n</code></pre>"},{"location":"#delete-documents","title":"Delete Documents","text":"<p>Here's a simple example of deleting documents from a collection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    client,err := chroma.NewClient() //connects to localhost:8000\n\n    openaiEf, err := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"))\n    if err != nil {\n        log.Fatalf(\"Error creating OpenAI embedding function: %s \\n\", err)\n    }\n    // Get the collection we created earlier\n    collection, err := client.GetCollection(ctx, \"my-collection\", openaiEf)\n    if err != nil {\n        log.Fatalf(\"Failed to create collection: %v\", err)\n        return\n    }\n    _, err = collection.Delete(context.TODO(), []string{\"ID1\"}, nil, nil)\n    if err != nil {\n        log.Fatalf(\"Error deleting documents: %v\\n\", err)\n        return\n    }\n    fmt.Printf(\"Documents deleted\\n\")\n}\n</code></pre>"},{"location":"auth/","title":"Authentication","text":"<p>Chroma supports multiple authentication methods. All methods work with both self-hosted and Chroma Cloud deployments.</p> <p>\ud83d\udcc1 Complete Examples: Find runnable authentication examples in the <code>examples/v2/auth</code> directory.</p>"},{"location":"auth/#api-v2-recommended","title":"API v2 (Recommended)","text":""},{"location":"auth/#basic-authentication","title":"Basic Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithAuth(v2.NewBasicAuthCredentialsProvider(\"admin\", \"password\")),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-bearer","title":"Token Authentication - Bearer","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithAuth(v2.NewTokenAuthCredentialsProvider(\"my-token\", v2.AuthorizationTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-x-chroma-token","title":"Token Authentication - X-Chroma-Token","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithAuth(v2.NewTokenAuthCredentialsProvider(\"my-token\", v2.XChromaTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#custom-headers","title":"Custom Headers","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    headers := map[string]string{\n        \"Authorization\": \"Bearer custom-token\",\n        \"X-Custom-Header\": \"custom-value\",\n    }\n\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithDefaultHeaders(headers),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#chroma-cloud-authentication","title":"Chroma Cloud Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    client, err := v2.NewCloudClient(\n        v2.WithCloudAPIKey(\"your-api-key\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#api-v1-legacy","title":"API v1 (Legacy)","text":""},{"location":"auth/#basic-authentication_1","title":"Basic Authentication","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithAuth(types.NewBasicAuthCredentialsProvider(\"admin\", \"password\")),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-bearer_1","title":"Token Authentication - Bearer","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-token\", types.AuthorizationTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#token-authentication-x-chroma-token_1","title":"Token Authentication - X-Chroma-Token","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/types\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithAuth(types.NewTokenAuthCredentialsProvider(\"my-token\", types.XChromaTokenHeader)),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"auth/#custom-headers_1","title":"Custom Headers","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    headers := map[string]string{\n        \"Authorization\": \"Bearer custom-token\",\n        \"X-Custom-Header\": \"custom-value\",\n    }\n\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithDefaultHeaders(headers),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if _, err := client.Heartbeat(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"client/","title":"Chroma Client","text":""},{"location":"client/#chroma-cloud-client-v020","title":"Chroma Cloud Client (v0.2.0+)","text":"<p>Options:</p> Options Usage Description Value Required CloudAPIKey <code>WithCloudAPIKey(\"api_key\")</code> Set Chroma Cloud API Key <code>string</code> Yes (default: uses <code>CHROMA_API_KEY</code> env var if available) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> Yes (default: uses <code>CHROMA_TENANT</code> env var if available) Database <code>WithDatabaseAndTenant(\"database\",\"tenant\")</code> The default database and tenant (overrides any tenant set with Tenant). Option precedence is observed! <code>string</code> Yes (default: uses <code>CHROMA_DATABASE</code> env var if available) ~~Debug~~ ~~<code>WithDebug()</code>~~ DEPRECATED ~~Enable debug mode~~ Use <code>WithLogger</code> with debug level instead <code>bool</code> No (deprecated - use WithLogger) Logger <code>WithLogger(logger)</code> Set a custom logger for HTTP request/response logging. See logging docs <code>logger.Logger</code> No (default: NoopLogger) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default HTTP headers for the client. These headers are sent with every request. <code>map[string]string</code> No (default: <code>nil</code>) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) Timeout <code>WithTimeout(time.Duration)</code> Set the timeout for the client. <code>time.Duration</code> No (default is the default HTTP client timeout duration) <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n    \"log\"\n)\n\nfunc main() {\n    c, err := chroma.NewHTTPClient(\n        chroma.WithCloudAPIKey(\"my-api-key\"),\n        chroma.WithDatabaseAndTenant(\"team-uuid\", \"my-database\"),\n        // chroma.WithDebug() is deprecated - use WithLogger instead for debug output\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    v, err := c.GetVersion(context.Background())\n    if err != nil {\n        log.Fatalf(\"Error getting version: %s \\n\", err)\n    }\n    fmt.Printf(\"Chroma API Version: %s \\n\", v)\n}\n</code></pre>"},{"location":"client/#chroma-client-v020","title":"Chroma Client (v0.2.0+)","text":"<p>Options:</p> Options Usage Description Value Required API Endpoint <code>WithBasePath(\"http://localhost:8000\")</code> The Chroma server base API. Non-empty valid URL string No (default: <code>http://localhost:8000</code>) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> No (default: <code>default_tenant</code>) Database <code>WithDatabaseAndTenant(\"database\",\"tenant\")</code> The default database to use. <code>string</code> No (default: <code>default_database</code>) ~~Debug~~ ~~<code>WithDebug()</code>~~ DEPRECATED ~~Enable debug mode~~ Use <code>WithLogger</code> with debug level instead <code>bool</code> No (deprecated - use WithLogger) Logger <code>WithLogger(logger)</code> Set a custom logger for HTTP request/response logging. See logging docs <code>logger.Logger</code> No (default: NoopLogger) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default HTTP headers for the client. These headers are sent with every request. <code>map[string]string</code> No (default: <code>nil</code>) SSL Cert <code>WithSSLCert(\"path/to/cert.pem\")</code> Set the path to the SSL certificate. valid path to SSL cert. No (default: Not Set) Insecure <code>WithInsecure()</code> Disable SSL certificate verification No (default: Not Set) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) Auth <code>WithAuth(v2.CredentialsProvider)</code> Set the authentication method. The default is <code>WithAuth(types.NewNoAuthCredentialsProvider())</code> <code>CredentialsProvider</code> No (default: <code>NoAuth</code>) Timeout <code>WithTimeout(time.Duration)</code> Set the timeout for the client. <code>time.Duration</code> No (default is the default HTTP client timeout duration) Transport <code>WithTransport(*http.Transport)</code> Set the transport for the client. <code>http.RoundTripper</code> No (default: Default HTTPClient) <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n    \"log\"\n)\n\nfunc main() {\n    c, err := chroma.NewHTTPClient(\n        chroma.WithBaseURL(\"http://localhost:8000\"),\n        chroma.WithDatabaseAndTenant(\"default_database\", \"default_tenant\"),\n        chroma.WithDefaultHeaders(map[string]string{\"X-Custom-Header\": \"header-value\"}),\n        // chroma.WithDebug() is deprecated - use WithLogger instead for debug output\n    )\n    if err != nil {\n        log.Fatalf(\"Error creating client: %s \\n\", err)\n    }\n    v, err := c.GetVersion(context.Background())\n    if err != nil {\n        log.Fatalf(\"Error getting version: %s \\n\", err)\n    }\n    fmt.Printf(\"Chroma API Version: %s \\n\", v)\n}\n</code></pre>"},{"location":"client/#client-version-v014-or-lower","title":"Client version v0.1.4 or lower","text":"<p>Options:</p> Options Usage Description Value Required basePath <code>WithBasePath(\"http://localhost:8000\")</code> The Chroma server base API. Non-empty valid URL string No (default: <code>http://localhost:8000</code>) Tenant <code>WithTenant(\"tenant\")</code> The default tenant to use. <code>string</code> No (default: <code>default_tenant</code>) Database <code>WithDatabase(\"database\")</code> The default database to use. <code>string</code> No (default: <code>default_database</code>) ~~Debug~~ ~~<code>WithDebug()</code>~~ DEPRECATED ~~Enable debug mode~~ Use <code>WithLogger</code> with debug level instead <code>bool</code> No (deprecated - use WithLogger) Logger <code>WithLogger(logger)</code> Set a custom logger for HTTP request/response logging. See logging docs <code>logger.Logger</code> No (default: NoopLogger) Default Headers <code>WithDefaultHeaders(map[string]string)</code> Set default headers for the client. <code>map[string]string</code> No (default: <code>nil</code>) SSL Cert <code>WithSSLCert(\"path/to/cert.pem\")</code> Set the path to the SSL certificate. valid path to SSL cert. No (default: Not Set) Insecure <code>WithInsecure()</code> Disable SSL certificate verification No (default: Not Set) Custom HttpClient <code>WithHTTPClient(http.Client)</code> Set a custom http client. If this is set then SSL Cert and Insecure options are ignore. <code>*http.Client</code> No (default: Default HTTPClient) <p>Tenant and Database</p> <p>The tenant and database are only supported for Chroma API version <code>0.4.15+</code>.</p> <p>Creating a new client:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    chroma \"github.com/amikos-tech/chroma-go\"\n)\n\nfunc main() {\n    client, err := chroma.NewClient(\n        chroma.WithBasePath(\"http://localhost:8000\"),\n        chroma.WithTenant(\"my_tenant\"),\n        chroma.WithDatabase(\"my_db\"),\n        // chroma.WithDebug(true) is deprecated - use WithLogger instead for debug output\n        chroma.WithDefaultHeaders(map[string]string{\"Authorization\": \"Bearer my token\"}),\n        chroma.WithSSLCert(\"path/to/cert.pem\"),\n    )\n    if err != nil {\n        fmt.Printf(\"Failed to create client: %v\", err)\n    }\n    // do something with client\n\n    // Close the client to release any resources such as local embedding functions\n    err = client.Close()\n    if err != nil {\n        fmt.Printf(\"Failed to close client: %v\", err)\n    }\n}\n</code></pre>"},{"location":"embeddings/","title":"Embedding Models","text":"<p>The following embedding wrappers are available:</p> Embedding Model Description Default Embeddings The default Chroma embedding function running <code>all-MiniLM-L6-v2</code> on Onnx Runtime OpenAI OpenAI embeddings API.All models are supported - see OpenAI docs for more info. Cohere Cohere embeddings API.All models are supported - see Cohere API docs for more info. HuggingFace Inference API HuggingFace Inference API.All models supported by the API. HuggingFace Embedding Inference Server HuggingFace Embedding Inference Server.Models supported by the inference server. Ollama Ollama embeddings API.All models are supported - see Ollama models lib for more info. Cloudflare Workers AI Cloudflare Workers AI Embedding. For more info see CF API Docs. Together AI Together AI Embedding. For more info see Together API Docs. Voyage AI Voyage AI Embedding. For more info see Together API Docs. Google Gemini Google Gemini Embedding. For more info see Gemini Docs. Mistral AI Mistral AI Embedding. For more info see Mistral AI API Docs. Nomic AI Nomic AI Embedding. For more info see Nomic AI API Docs. Jina AI Jina AI Embedding. For more info see Nomic AI API Docs."},{"location":"embeddings/#default-embeddings","title":"Default Embeddings","text":"<p>Note: Supported from 0.2.0+</p> <p>The default embedding function uses the <code>all-MiniLM-L6-v2</code> model running on Onnx Runtime. The default EF is configured by default if no EF is provided when creating or getting a collection.</p> <p>Note: As the EF relies on C bindings to avoid memory leaks make sure to call the close callback, alternatively if you are passing the EF to a client e.g. when getting or creating a collection you can use the client's close method to ensure proper resource release.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    defaultef \"github.com/amikos-tech/chroma-go/pkg/embeddings/default_ef\"\n)\n\nfunc main() {\n    ef, closeef, efErr := defaultef.NewDefaultEmbeddingFunction()\n\n    // make sure to call this to ensure proper resource release\n    defer func() {\n        err := closeef()\n        if err != nil {\n            fmt.Printf(\"Error closing default embedding function: %s \\n\", err)\n        }\n    }()\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#openai","title":"OpenAI","text":"<p>Supported Embedding Function Options:</p> <ul> <li><code>WithModel</code> - Set the OpenAI model to use. Default is <code>TextEmbeddingAda002</code> (<code>text-embedding-ada-002</code>).</li> <li><code>WithBaseURL</code> - Set the OpenAI base URL. Default is <code>https://api.openai.com/v1</code>. This allows you to point the EF to a   compatible OpenAI API endpoint.</li> <li><code>WithDimensions</code> - Set the number of dimensions for the embeddings. Default is <code>None</code> which returns the full   embeddings.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    openai \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n)\n\nfunc main() {\n    ef, efErr := openai.NewOpenAIEmbeddingFunction(os.Getenv(\"OPENAI_API_KEY\"), openai.WithModel(openai.TextEmbedding3Large))\n    if efErr != nil {\n        fmt.Printf(\"Error creating OpenAI embedding function: %s \\n\", efErr)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cohere","title":"Cohere","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    cohere \"github.com/amikos-tech/chroma-go/pkg/embeddings/cohere\"\n)\n\nfunc main() {\n    ef := cohere.NewCohereEmbeddingFunction(os.Getenv(\"COHERE_API_KEY\"))\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-inference-api","title":"HuggingFace Inference API","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/pkg/embeddings/hf\"\n)\n\nfunc main() {\n    ef := huggingface.NewHuggingFaceEmbeddingFunction(os.Getenv(\"HUGGINGFACE_API_KEY\"), \"sentence-transformers/all-MiniLM-L6-v2\")\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#huggingface-embedding-inference-server","title":"HuggingFace Embedding Inference Server","text":"<p>The embedding server allows you to run supported model locally on your machine with CPU and GPU inference. For more information check the HuggingFace Embedding Inference Server repository.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    huggingface \"github.com/amikos-tech/chroma-go/hf\"\n)\n\nfunc main() {\n    ef, err := huggingface.NewHuggingFaceEmbeddingInferenceFunction(\"http://localhost:8001/embed\") //set this to the URL of the HuggingFace Embedding Inference Server\n    if err != nil {\n        fmt.Printf(\"Error creating HuggingFace embedding function: %s \\n\", err)\n    }\n    documents := []string{\n        \"Document 1 content here\",\n    }\n    resp, reqErr := ef.EmbedDocuments(context.Background(), documents)\n    if reqErr != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", reqErr)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#ollama","title":"Ollama","text":"<p>Assumptions</p> <p>The below example assumes that you have an Ollama server running locally on <code>http://127.0.0.1:11434</code>.</p> <p>Use the following command to start the Ollama server:</p> <pre><code>    docker run -d -v ./ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama\n    docker exec -it ollama ollama run nomic-embed-text # press Ctrl+D to exit after model downloads successfully\n    # test it\n    curl http://localhost:11434/api/embed -d '{\"model\": \"nomic-embed-text\",\"input\": [\"Here is an article about llamas...\"]}'\n ```\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    ollama \"github.com/amikos-tech/chroma-go/pkg/embeddings/ollama\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // the `/api/embeddings` endpoint is automatically appended to the base URL\n    ef, err := ollama.NewOllamaEmbeddingFunction(ollama.WithBaseURL(\"http://127.0.0.1:11434\"), ollama.WithModel(\"nomic-embed-text\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Ollama embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#cloudflare-workers-ai","title":"Cloudflare Workers AI","text":"<p>You will need to register for a Cloudflare account and create a API Token for Workers AI - see docs for more info.</p> <p>Models can be found in the Cloudflare Workers AI docs. <code>@cf/baai/bge-base-en-v1.5</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    cf \"github.com/amikos-tech/chroma-go/pkg/embeddings/cloudflare\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `CF_API_TOKEN` and `CF_ACCOUNT_ID` set in your environment\n    ef, err := cf.NewCloudflareEmbeddingFunction(cf.WithEnvAPIToken(), cf.WithEnvAccountID(), cf.WithDefaultModel(\"@cf/baai/bge-small-en-v1.5\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Cloudflare embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#together-ai","title":"Together AI","text":"<p>To use Together AI embeddings, you will need to register for a Together AI account and create an API Key.</p> <p>Available models can be in Together AI docs. <code>togethercomputer/m2-bert-80M-8k-retrieval</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/together\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `TOGETHER_API_KEY` set in your environment\n    ef, err := t.NewTogetherEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"togethercomputer/m2-bert-80M-2k-retrieval\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#voyage-ai","title":"Voyage AI","text":"<p>To use Voyage AI embeddings, you will need to register for a Voyage AI account and create an API Key.</p> <p>Available models can be in Voyage AI docs. <code>voyage-2</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    t \"github.com/amikos-tech/chroma-go/pkg/embeddings/voyage\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `VOYAGE_API_KEY` set in your environment\n    ef, err := t.NewVoyageAIEmbeddingFunction(t.WithEnvAPIKey(), t.WithDefaultModel(\"voyage-large-2\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Together embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#google-gemini","title":"Google Gemini","text":"<p>To use Google Gemini AI embeddings, you will need to create an API Key.</p> <p>Available models can be in Gemini Models. <code>text-embedding-004</code> is the default model.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    g \"github.com/amikos-tech/chroma-go/pkg/embeddings/gemini\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `GEMINI_API_KEY` set in your environment\n    ef, err := g.NewGeminiEmbeddingFunction(g.WithEnvAPIKey(), g.WithDefaultModel(\"text-embedding-004\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Gemini embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#mistral-ai","title":"Mistral AI","text":"<p>To use Mistral AI embeddings, you will need to create an API Key.</p> <p>Currently, (as of July 2024) only <code>mistral-embed</code> model is available, which is the default model we use.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    mistral \"github.com/amikos-tech/chroma-go/pkg/embeddings/mistral\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `MISTRAL_API_KEY` set in your environment\n    ef, err := mistral.NewMistralEmbeddingFunction(mistral.WithEnvAPIKey(), mistral.WithDefaultModel(\"mistral-embed\"))\n    if err != nil {\n        fmt.Printf(\"Error creating Mistral embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#nomic-ai","title":"Nomic AI","text":"<p>To use Nomic AI embeddings, you will need to create an API Key.</p> <p>Supported models - https://docs.nomic.ai/atlas/models/text-embedding</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    nomic \"github.com/amikos-tech/chroma-go/pkg/embeddings/nomic\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `NOMIC_API_KEY` set in your environment\n    ef, err := nomic.NewNomicEmbeddingFunction(nomic.WithEnvAPIKey(), nomic.WithDefaultModel(nomic.NomicEmbedTextV1))\n    if err != nil {\n        fmt.Printf(\"Error creating Nomic embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"embeddings/#jina-ai","title":"Jina AI","text":"<p>To use Jina AI embeddings, you will need to get an API Key (trial API keys are freely available without any registration, scroll down the page and find the automatically generated API key).</p> <p>Supported models - https://api.jina.ai/redoc#tag/embeddings/operation/create_embedding_v1_embeddings_post</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    jina \"github.com/amikos-tech/chroma-go/pkg/embeddings/jina\"\n)\n\nfunc main() {\n    documents := []string{\n        \"Document 1 content here\",\n        \"Document 2 content here\",\n    }\n    // Make sure that you have the `JINA_API_KEY` set in your environment\n    ef, err := jina.NewJinaEmbeddingFunction(jina.WithEnvAPIKey())\n    if err != nil {\n        fmt.Printf(\"Error creating Jina embedding function: %s \\n\", err)\n    }\n    resp, err := ef.EmbedDocuments(context.Background(), documents)\n    if err != nil {\n        fmt.Printf(\"Error embedding documents: %s \\n\", err)\n    }\n    fmt.Printf(\"Embedding response: %v \\n\", resp)\n}\n</code></pre>"},{"location":"filtering/","title":"Filtering","text":"<p>Chroma offers two types of filters:</p> <ul> <li>Metadata - filtering based on metadata attribute values</li> <li>Documents - filtering based on document content (contains or not contains)</li> </ul>"},{"location":"filtering/#metadata","title":"Metadata","text":"<ul> <li>TODO - Add builder example</li> <li>TODO - Describe all available operations</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    \"github.com/amikos-tech/chroma-go/where\"\n)\n\nfunc main() {\n    embeddingF, err := openai.NewOpenAIEmbeddingFunction(\"sk-xxxx\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    client, err := chroma.NewClient() // connects to localhost:8000\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    collection, err := client.GetCollection(context.TODO(), \"my-collection\", embeddingF)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // Filter by metadata\n\n    result, err := collection.GetWithOptions(\n        context.Background(),\n        types.WithWhere(\n            where.Or(\n                where.Eq(\"category\", \"Chroma\"),\n                where.Eq(\"type\", \"vector database\"),\n            ),\n        ),\n    )\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // do something with result\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"filtering/#document","title":"Document","text":"<ul> <li>TODO - Add builder example</li> <li>TODO - Describe all available operations</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    chroma \"github.com/amikos-tech/chroma-go\"\n    \"github.com/amikos-tech/chroma-go/pkg/embeddings/openai\"\n    \"github.com/amikos-tech/chroma-go/types\"\n    \"github.com/amikos-tech/chroma-go/where_document\"\n)\n\nfunc main() {\n    embeddingF, err := openai.NewOpenAIEmbeddingFunction(\"sk-xxxx\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    client, err := chroma.NewClient(chroma.WithBasePath(\"http://localhost:8000\"))\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    collection, err := client.GetCollection(context.TODO(), \"my-collection\", embeddingF)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // Filter by metadata\n\n    result, err := collection.GetWithOptions(\n        context.Background(),\n        types.WithWhereDocument(\n            wheredoc.Or(\n                wheredoc.Contains(\"Vector database\"),\n                wheredoc.Contains(\"Chroma\"),\n            ),\n        ),\n    )\n\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // do something with result\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"logging/","title":"Logging","text":"<p>V2 API Only</p> <p>The logging feature is only available for the V2 API. V1 API uses standard library logging and is maintained for backward compatibility.</p>"},{"location":"logging/#overview","title":"Overview","text":"<p>The chroma-go V2 client provides a flexible logging interface that allows you to inject custom loggers instead of using stdio for debug output. This feature enables better integration with your application's logging infrastructure and provides structured logging capabilities.</p>"},{"location":"logging/#features","title":"Features","text":"<ul> <li>Pluggable Logger Interface: Define your own logger implementation or use the provided ones</li> <li>Structured Logging: Support for structured fields and context-aware logging</li> <li>Multiple Log Levels: Debug, Info, Warn, and Error levels</li> <li>Context Support: Pass context for distributed tracing and request correlation</li> <li>Zero Allocation: NoopLogger for production scenarios where logging should be disabled</li> </ul>"},{"location":"logging/#logger-interface","title":"Logger Interface","text":"<p>The Logger interface defines the contract for all logger implementations:</p> <pre><code>type Logger interface {\n    // Standard logging methods\n    Debug(msg string, fields ...Field)\n    Info(msg string, fields ...Field)\n    Warn(msg string, fields ...Field)\n    Error(msg string, fields ...Field)\n\n    // Context-aware logging methods\n    DebugWithContext(ctx context.Context, msg string, fields ...Field)\n    InfoWithContext(ctx context.Context, msg string, fields ...Field)\n    WarnWithContext(ctx context.Context, msg string, fields ...Field)\n    ErrorWithContext(ctx context.Context, msg string, fields ...Field)\n\n    // With returns a new logger with the given fields\n    With(fields ...Field) Logger\n\n    // Enabled returns true if the given level is enabled\n    IsDebugEnabled() bool\n}\n</code></pre>"},{"location":"logging/#built-in-implementations","title":"Built-in Implementations","text":""},{"location":"logging/#zaplogger","title":"ZapLogger","text":"<p>The ZapLogger wraps uber-go/zap for high-performance structured logging.</p> <pre><code>import (\n    \"go.uber.org/zap\"\n    chromalogger \"github.com/amikos-tech/chroma-go/pkg/logger\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\n// Create a zap logger\nzapLogger, _ := zap.NewProduction()\n\n// Wrap it in ChromaLogger\nlogger := chromalogger.NewZapLogger(zapLogger)\n\n// Use it with the client\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre>"},{"location":"logging/#development-logger","title":"Development Logger","text":"<p>For development, you can use a pre-configured development logger:</p> <pre><code>logger, _ := chromalogger.NewDevelopmentZapLogger()\n\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre>"},{"location":"logging/#nooplogger","title":"NoopLogger","text":"<p>The NoopLogger discards all log messages and is useful for production scenarios where you want to disable logging completely:</p> <pre><code>logger := chromalogger.NewNoopLogger()\n\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre>"},{"location":"logging/#using-withdebug-deprecated","title":"Using WithDebug() (DEPRECATED)","text":"<p>\u26a0\ufe0f DEPRECATED: <code>WithDebug()</code> is deprecated and will be removed in a future version. Use <code>WithLogger()</code> with a debug-level logger instead.</p> <pre><code>// DEPRECATED - Do not use\n// client, err := v2.NewHTTPClient(\n//     v2.WithBaseURL(\"http://localhost:8000\"),\n//     v2.WithDebug(),\n// )\n\n// RECOMMENDED - Use WithLogger instead\nlogger, _ := chromalogger.NewDevelopmentZapLogger()\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger), // Provides debug-level logging\n)\n</code></pre>"},{"location":"logging/#structured-logging-with-fields","title":"Structured Logging with Fields","text":"<p>The logger supports structured logging with fields for better log analysis:</p> <pre><code>logger := chromalogger.NewDevelopmentZapLogger()\n\n// Create a logger with persistent fields\nrequestLogger := logger.With(\n    chromalogger.String(\"request_id\", \"123\"),\n    chromalogger.String(\"user_id\", \"user-456\"),\n)\n\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(requestLogger),\n)\n</code></pre>"},{"location":"logging/#field-helpers","title":"Field Helpers","text":"<p>The logger package provides convenient field constructors:</p> <pre><code>chromalogger.String(\"key\", \"value\")\nchromalogger.Int(\"count\", 42)\nchromalogger.Bool(\"enabled\", true)\nchromalogger.ErrorField(\"error\", err)\nchromalogger.Any(\"data\", complexObject)\n</code></pre>"},{"location":"logging/#context-aware-logging","title":"Context-Aware Logging","text":"<p>For distributed tracing and request correlation, use the context-aware methods:</p> <pre><code>ctx := context.WithValue(context.Background(), \"trace-id\", \"abc123\")\n\n// The logger implementation can extract values from context\nlogger.InfoWithContext(ctx, \"Processing request\",\n    chromalogger.String(\"operation\", \"query\"),\n)\n</code></pre>"},{"location":"logging/#custom-logger-implementation","title":"Custom Logger Implementation","text":"<p>You can implement your own logger by implementing the Logger interface:</p> <pre><code>type MyCustomLogger struct {\n    // your logger implementation\n}\n\nfunc (l *MyCustomLogger) Debug(msg string, fields ...chromalogger.Field) {\n    // implement debug logging\n}\n\nfunc (l *MyCustomLogger) Info(msg string, fields ...chromalogger.Field) {\n    // implement info logging\n}\n\n// ... implement other required methods\n\n// Use your custom logger\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(&amp;MyCustomLogger{}),\n)\n</code></pre>"},{"location":"logging/#cloud-client-support","title":"Cloud Client Support","text":"<p>The logging feature is also available for the Cloud client:</p> <pre><code>logger := chromalogger.NewDevelopmentZapLogger()\n\nclient, err := v2.NewCloudClient(\n    v2.WithLogger(logger),\n    v2.WithCloudAPIKey(\"your-api-key\"),\n    v2.WithDatabaseAndTenant(\"database\", \"tenant\"),\n)\n</code></pre>"},{"location":"logging/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Use NoopLogger in Production: If you don't need logging, use NoopLogger to avoid any performance overhead</li> <li>Check IsDebugEnabled(): Before expensive debug operations, check if debug logging is enabled</li> <li>Use Structured Fields: Instead of string formatting, use structured fields for better performance</li> <li>Reuse Loggers: Create loggers with common fields using <code>With()</code> and reuse them</li> </ol>"},{"location":"logging/#example-complete-logging-setup","title":"Example: Complete Logging Setup","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"go.uber.org/zap\"\n    \"go.uber.org/zap/zapcore\"\n\n    chromalogger \"github.com/amikos-tech/chroma-go/pkg/logger\"\n    v2 \"github.com/amikos-tech/chroma-go/pkg/api/v2\"\n)\n\nfunc main() {\n    // Configure zap logger\n    config := zap.NewProductionConfig()\n    config.Level = zap.NewAtomicLevelAt(zapcore.DebugLevel)\n    config.OutputPaths = []string{\"stdout\", \"/var/log/chroma-client.log\"}\n\n    zapLogger, err := config.Build()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer zapLogger.Sync()\n\n    // Create chroma logger\n    logger := chromalogger.NewZapLogger(zapLogger)\n\n    // Add request-specific fields\n    requestLogger := logger.With(\n        chromalogger.String(\"service\", \"my-app\"),\n        chromalogger.String(\"version\", \"1.0.0\"),\n    )\n\n    // Create client with logger\n    client, err := v2.NewHTTPClient(\n        v2.WithBaseURL(\"http://localhost:8000\"),\n        v2.WithLogger(requestLogger),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Use the client - all operations will be logged\n    ctx := context.Background()\n    collections, err := client.ListCollections(ctx)\n    if err != nil {\n        requestLogger.Error(\"Failed to list collections\",\n            chromalogger.ErrorField(\"error\", err),\n        )\n        return\n    }\n\n    requestLogger.Info(\"Listed collections successfully\",\n        chromalogger.Int(\"count\", len(collections)),\n    )\n}\n</code></pre>"},{"location":"logging/#migration-from-debug-flag","title":"Migration from Debug Flag","text":"<p>\u26a0\ufe0f IMPORTANT: <code>WithDebug()</code> is deprecated. Migrate to <code>WithLogger()</code> for debug logging.</p> <p>Before (DEPRECATED): <pre><code>client, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithDebug(), // DEPRECATED - only prints a warning now\n)\n</code></pre></p> <p>After (RECOMMENDED): <pre><code>// Use WithLogger with a debug-level logger\nlogger, _ := chromalogger.NewDevelopmentZapLogger()\nclient, err := v2.NewHTTPClient(\n    v2.WithBaseURL(\"http://localhost:8000\"),\n    v2.WithLogger(logger),\n)\n</code></pre></p>"},{"location":"logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"logging/#no-logs-appearing","title":"No logs appearing","text":"<ol> <li>Check if your logger is properly configured and the log level allows the messages</li> <li>Ensure you're not using NoopLogger unintentionally</li> <li>For custom loggers, verify your implementation outputs to the expected destination</li> </ol>"},{"location":"logging/#too-many-logs","title":"Too many logs","text":"<ol> <li>Adjust the log level in your logger configuration</li> <li>Use NoopLogger for specific operations that don't need logging</li> <li>Consider using a logger with filtering capabilities</li> </ol>"},{"location":"logging/#performance-impact","title":"Performance impact","text":"<ol> <li>Use NoopLogger in production if logging is not needed</li> <li>Avoid expensive operations in log message formatting</li> <li>Use structured fields instead of string concatenation</li> </ol>"},{"location":"records/","title":"Records","text":"<p>Records are a mechanism that allows you to manage Chroma documents as a cohesive unit. This has several advantages over the traditional approach of managing documents, ids, embeddings, and metadata separately.</p> <p>Two concepts are important to keep in mind here:</p> <ul> <li>Record - corresponds to a single document in Chroma which includes id, embedding, metadata, the document or URI</li> <li>RecordSet - a single unit of work to insert, upsert, update or delete records.</li> </ul>"},{"location":"records/#record","title":"Record","text":"<p>A Record contains the following fields:</p> <ul> <li>ID (string)</li> <li>Document (string) - optional</li> <li>Metadata (map[string]interface{}) - optional</li> <li>Embedding ([]float32 or []int32, wrapped in Embedding struct)</li> <li>URI (string) - optional</li> </ul> <p>Here's the <code>Record</code> type:</p> <pre><code>package types\n\ntype Record struct {\n    ID        string\n    Embedding Embedding\n    Metadata  map[string]interface{}\n    Document  string\n    URI       string\n    err       error // indicating whether the record is valid\n}\n</code></pre>"},{"location":"records/#recordset","title":"RecordSet","text":"<p>A record set is a cohesive unit of work, allowing the user to add, upsert, update, or delete records.</p> <p>Operation support</p> <p>Currently the record set only supports add operation</p> <pre><code>rs, rerr := types.NewRecordSet(\n            types.WithEmbeddingFunction(types.NewConsistentHashEmbeddingFunction()),\n            types.WithIDGenerator(types.NewULIDGenerator()),\n        )\nif err != nil {\n    log.Fatalf(\"Error creating record set: %s\", err)\n}\n// you can loop here to add multiple records\nrs.WithRecord(types.WithDocument(\"Document 1 content\"), types.WithMetadata(\"key1\", \"value1\"))\nrs.WithRecord(types.WithDocument(\"Document 2 content\"), types.WithMetadata(\"key2\", \"value2\"))\nrecords, err = rs.BuildAndValidate(context.Background())\n</code></pre>"},{"location":"rerankers/","title":"Reranking Functions","text":"<p>Reranking functions allow users to feed Chroma results into a reranking model such as <code>cross-encoder/ms-marco-MiniLM-L-6-v2</code> to improve the quality of the search results.</p> <p>Rerankers take the returned documents from Chroma and the original query and rank each result's relevance to the query.</p>"},{"location":"rerankers/#how-to-use-rerankers","title":"How To Use Rerankers","text":"<p>Each reranker exposes the following methods:</p> <ul> <li><code>Rerank</code> which takes plain text query and results and returns a list of ranked results.</li> <li><code>RerankResults</code> which takes a <code>QueryResults</code> object and returns a list of <code>RerankedChromaResults</code> objects. RerankedChromaResults inherits from <code>QueryResults</code> and adds a <code>Ranks</code> field which contains the ranks of each result.</li> </ul> <pre><code>package rerankings\n\nimport (\n    \"context\"\n\n    chromago \"github.com/amikos-tech/chroma-go\"\n)\n\ntype RankedResult struct {\n    ID     int // Index in the original input []string\n    String string\n    Rank   float32\n}\n\ntype RerankedChromaResults struct {\n    chromago.QueryResults\n    Ranks [][]float32\n}\n\ntype RerankingFunction interface {\n    Rerank(ctx context.Context, query string, results []string) ([]*RankedResult, error)\n    RerankResults(ctx context.Context, queryResults *chromago.QueryResults) (RerankedChromaResults, error)\n}\n</code></pre>"},{"location":"rerankers/#supported-rerankers","title":"Supported Rerankers","text":"<ul> <li>Cohere - \u2705</li> <li>Jina AI - \u2705 </li> <li>HuggingFace Text Embedding Inference - \u2705</li> <li>HuggingFace Inference API - coming soon</li> </ul>"},{"location":"rerankers/#cohere-reranker","title":"Cohere Reranker","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    cohere \"github.com/amikos-tech/chroma-go/pkg/rerankings/cohere\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := cohere.NewCohereRerankingFunction(cohere.WithAPIKey(os.Getenv(\"COHERE_API_KEY\")))\n    if err != nil {\n        fmt.Printf(\"Error creating Cohere reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"rerankers/#jina-ai-reranker","title":"Jina AI Reranker","text":"<p>To use Jina AI reranking, you will need to get an API Key (trial API keys are freely available without any registration, scroll down the page and find the automatically generated API key).</p> <p>Supported models - https://api.jina.ai/redoc#tag/rerank/operation/rank_v1_rerank_post</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    jina \"github.com/amikos-tech/chroma-go/pkg/rerankings/jina\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := jina.NewJinaRerankingFunction(jina.WithAPIKey(os.Getenv(\"JINA_API_KEY\")))\n    if err != nil {\n        fmt.Printf(\"Error creating Jina reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"},{"location":"rerankers/#hfei-reranker","title":"HFEI Reranker","text":"<p>You need to run a local HFEI server. You can do that by running the following command:</p> <pre><code>docker run --rm -p 8080:80 -v $PWD/data:/data --platform linux/amd64 ghcr.io/huggingface/text-embeddings-inference:cpu-latest --model-id BAAI/bge-reranker-base\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    hf \"github.com/amikos-tech/chroma-go/pkg/rerankings/hf\"\n    \"os\"\n)\n\nfunc main() {\n    var query = \"What is the capital of the United States?\"\n    var results = []string{\n        \"Carson City is the capital city of the American state of Nevada.\",\n        \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean that are a political division controlled by the United States. Its capital is Saipan.\",\n        \"Charlotte Amalie is the capital and largest city of the United States Virgin Islands. It has about 20,000 people. The city is on the island of Saint Thomas.\",\n        \"Washington, D.C. (also known as simply Washington or D.C., and officially as the District of Columbia) is the capital of the United States.\",\n        \"Capital punishment (the death penalty) has existed in the United States since before the United States was a country.\",\n    }\n\n    rf, err := hf.NewHFRerankingFunction(hf.WithRerankingEndpoint(\"http://127.0.0.1:8080/rerank\"))\n    if err != nil {\n        fmt.Printf(\"Error creating HFEI reranking function: %s \\n\", err)\n    }\n\n    res, err := rf.Rerank(context.Background(), query, results)\n    if err != nil {\n        fmt.Printf(\"Error reranking: %s \\n\", err)\n    }\n\n    for _, rs := range res[rf.ID()] {\n        fmt.Printf(\"Rank: %f, Index: %d\\n\", rs.Rank, rs.Index)\n    }\n}\n</code></pre>"}]}